# 索引迁移与虚拟滚动验证报告

本文档记录 Service Worker 与前端 IndexedDB 索引对齐的现状、验证步骤与结论；同时确认管理页树组件的虚拟滚动阈值设置，并给出分页/无限滚动与 Web Worker 预处理的评估建议。

## 背景与目标

- 历史上 Service Worker（SW）与前端对书签表的索引配置存在差异，导致架构升级时可能出现索引冗余或缺失。
- 目标：在数据库升级事务中对齐索引（添加缺失、删除废弃），并确认前端列表的虚拟滚动阈值为 500。

## 现状结论（代码对齐）

- SW IndexedDB 配置：`background.js` 中 `DB_CONFIG.VERSION = 7`，升级事件 `onupgradeneeded` 中传递事务对象给 `_createStores(db, tx)`。
- 书签表索引：
  - 必需索引（required）：`parentId`、`urlLower`、`parentId_index`（复合：`['parentId','index']`）、`url`、`domain`、`titleLower`、`pathIds(multiEntry)`、`keywords(multiEntry)`、`tags(multiEntry)`、`dateAdded`
  - 废弃索引（deprecated，按需清理）：`depth`、`isFolder`、`category`、`createdYear`、`visitCount`
- SW 在对象存储已存在时，会：
  - 读取 `indexNames`，为 `required` 列表中缺失的索引执行 `createIndex`
  - 对 `deprecated` 列表中存在的索引执行 `deleteIndex`
- 前端 IndexedDB 架构：`frontend/src/utils/indexeddb-schema.ts`、`indexeddb-manager.ts` 已定义相同的索引集与迁移逻辑（添加缺失、删除冗余）。

## 关键用例核对

- `parentId_index`（复合索引）已在 SW 创建，并在获取某父节点的子项时用于有序游标（对齐前端使用）。
- `urlLower`、`titleLower` 用于不区分大小写匹配；`pathIds`、`keywords`、`tags` 为 `multiEntry`，支持多值查询；`dateAdded` 用于时间排序或范围查询。
- 废弃索引的清理与代码引用核对：未发现活跃使用的路径依赖 `depth/isFolder/category/createdYear/visitCount` 索引，删除安全。

## 虚拟滚动阈值确认

- 管理页树组件：`frontend/src/components/SimpleBookmarkTree.vue`
  - `normalizedVirtual` 对 `props.virtual` 进行规范化，当传入 boolean 时默认 `threshold: 500`。
  - 自动启用逻辑：统计节点总数（含文件夹与书签），当 `count > threshold` 且不处于 `strictChromeOrder` 模式即启用虚拟滚动。
  - 使用 `@tanstack/vue-virtual`，`overscan: 5`，`estimateSize` 依据尺寸变体计算（紧凑 28px/舒适 32px/宽松 40px）。
- 结论：虚拟滚动默认阈值已为 500，无需代码调整。

## 验证步骤与结果

1. 触发数据库升级：重新加载扩展以确保 `onupgradeneeded` 执行；SW 日志中出现“数据库升级”和“表结构创建完成”提示。
2. 索引校验：
   - 观察 SW 日志：缺失索引的“已添加”提示、废弃索引的“已删除”提示；
   - 验证 `bookmarks` 存储包含 `parentId_index`、`urlLower` 等索引；
3. 前端列表性能：在超过 500 个节点的集合上，`SimpleBookmarkTree` 进入虚拟模式；滚动与搜索交互流畅。
4. 兼容性：未发现依赖已废弃索引的路径； CRUD 与搜索功能正常。

## 风险与回滚策略

- 升级阻塞：SW 中已记录 `onblocked`，提示可能被其他标签页占用；关闭其他页面后重试。
- 索引迁移开销：大数据集删除/创建索引可能耗时；建议在首次升级后保持稳定架构，避免频繁变更。
- 回滚：若需恢复旧索引，可在新版本中临时加入兼容创建，但当前不建议（将增加写入成本且无明确使用场景）。

## 后续优化建议

### 1) 管理页分页或无限滚动（评估）

- 问题：当严格顺序渲染且展开层级较多时，即使虚拟滚动启用，深层懒加载仍可能带来一次性渲染压力。
- 方案对比：
  - 无限滚动（首选）：结合虚拟滚动与懒加载，将子节点加载与渲染分段化，维持连续滚动体验；
  - 分页（可选）：为管理页提供按文件夹或搜索结果分页视图，降低一次性 DOM 和数据体积；
- 推荐路径：先完善“懒加载 + 虚拟滚动”的协同（确保仅在可见区域附近加载子节点），后续再引入分页视图作为大数据集的备选入口（例如切换到扁平列表 + 分页）。

### 2) Web Worker 预处理（评估）

- 目的：在导入或首次同步书签时，将 `titleLower/urlLower/domain/keywords` 等字段预处理移至 Worker，避免阻塞主线程或 SW 的热路径。
- 接口草案：
  - 输入：`{ type: 'PREPROCESS_BOOKMARKS', data: Bookmark[] }`
  - 输出：`{ type: 'PROCESSED', data: BookmarkProcessed[] }`
- 示例片段：

```ts
self.onmessage = async e => {
  const { type, data } = e.data
  if (type === 'PREPROCESS_BOOKMARKS') {
    const processed = data.map(b => ({
      ...b,
      titleLower: b.title?.toLowerCase() || '',
      urlLower: b.url?.toLowerCase() || '',
      domain: extractDomain(b.url),
      keywords: extractKeywords(b.title, b.url)
    }))
    self.postMessage({ type: 'PROCESSED', data: processed })
  }
}
```

- 集成建议：在 SW 或前端加载大量书签时，先通过 Worker 预处理再批量写入 IndexedDB（结合事务与指数退避），提高总体吞吐。

## 结语

当前代码已实现 SW/前端索引对齐与虚拟滚动阈值（500）默认配置。建议后续按上述评估逐步引入无限滚动协同与 Worker 预处理，以进一步优化十万级数据的交互性能与稳定性。
