# 🛠️ AcuityBookmarks 架构优化实施指南

> **基于**: 代码架构审核报告
> **目标**: 逐步优化项目架构，提升代码质量和可维护性
> **原则**: 渐进式重构，小步快跑，持续验证

---

## 📋 总体策略

### ✅ DO (推荐做法)
- ✅ **小步重构**: 每次只改一个模块，立即测试
- ✅ **保持兼容**: 新旧代码并存，逐步迁移
- ✅ **持续验证**: 每次重构后运行测试和 lint
- ✅ **文档同步**: 代码变更同时更新文档
- ✅ **团队协作**: 重构前与团队沟通，避免冲突

### ❌ DON'T (避免做法)
- ❌ **大爆炸重构**: 一次性改动大量代码
- ❌ **破坏兼容性**: 突然删除被使用的API
- ❌ **跳过测试**: 重构不测试 = 埋雷
- ❌ **过度优化**: 为优化而优化，忽略业务价值
- ❌ **孤军奋战**: 不与团队沟通的重构

---

## 🎯 阶段一：重构 utils 目录 (最高优先级)

### 背景
当前 `utils/` 目录包含 24 个文件，超过 11,000 行代码，职责严重混乱。需要按照分层架构重新组织。

### 目标
- 建立清晰的 `core/`、`infrastructure/`、`application/` 分层
- `utils/` 只保留纯工具函数
- 明确各层职责边界

---

### Step 1: 创建新目录结构 (1小时)

```bash
# 在 frontend/src 下创建新目录
cd /home/runner/work/acuityBookmarks/acuityBookmarks/frontend/src

# 创建核心层
mkdir -p core/bookmark/{domain,services,repositories}
mkdir -p core/search/strategies

# 创建基础设施层
mkdir -p infrastructure/{indexeddb,chrome-api,logging}

# 创建应用层
mkdir -p application/{bookmark,search,ui}

# 保留现有目录
# utils/ - 将只保留纯工具函数
# services/ - 逐步迁移到 core/
```

**验证**:
```bash
tree frontend/src -L 3 -d
```

---

### Step 2: 迁移文件 - 第一批 (2-3小时)

#### 2.1 迁移书签核心逻辑

**文件映射**:
```
utils/unified-bookmark-api.ts (1264行)
  → core/bookmark/repositories/bookmark-repository.ts (数据访问)
  → application/bookmark/bookmark-app-service.ts (应用服务)

utils/smart-bookmark-manager.ts (354行)
  → core/bookmark/services/bookmark-service.ts

utils/smart-bookmark-executor.ts (525行)
  → core/bookmark/services/bookmark-executor.ts

utils/smart-bookmark-diff-engine.ts (530行)
  → core/bookmark/services/bookmark-differ.ts
```

**具体步骤**:

```bash
# 1. 复制文件到新位置 (先复制，不删除原文件)
cp frontend/src/utils/unified-bookmark-api.ts \
   frontend/src/core/bookmark/repositories/bookmark-repository.ts

# 2. 在新文件中重构
# - 分离数据访问逻辑 (repository) 和应用逻辑 (app-service)
# - 移除不必要的依赖
# - 优化导入路径

# 3. 创建桥接层 (保持向后兼容)
# frontend/src/utils/unified-bookmark-api.ts (临时保留)
```

**示例重构 - bookmark-repository.ts**:

```typescript
// frontend/src/core/bookmark/repositories/bookmark-repository.ts
/**
 * 书签数据访问层
 * 职责：与 IndexedDB 和 Chrome API 交互
 */

import { indexedDBManager } from '@/infrastructure/indexeddb/manager'
import { chromeAPI } from '@/infrastructure/chrome-api/wrapper'
import type { BookmarkRecord } from '@/infrastructure/indexeddb/schema'
import type { Result } from '@/core/common/result'
import { logger } from '@/infrastructure/logging/logger'

export class BookmarkRepository {
  /**
   * 从 IndexedDB 获取所有书签
   */
  async getAllBookmarks(): Promise<Result<BookmarkRecord[]>> {
    try {
      const bookmarks = await indexedDBManager.getAllBookmarks()
      return { ok: true, value: bookmarks }
    } catch (error) {
      logger.error('BookmarkRepository', 'Failed to get all bookmarks', error)
      return { ok: false, error: error as Error }
    }
  }

  /**
   * 从 Chrome API 获取书签树
   */
  async getBookmarkTree(): Promise<Result<chrome.bookmarks.BookmarkTreeNode[]>> {
    try {
      const tree = await chromeAPI.getBookmarkTree()
      return { ok: true, value: tree }
    } catch (error) {
      logger.error('BookmarkRepository', 'Failed to get bookmark tree', error)
      return { ok: false, error: error as Error }
    }
  }

  /**
   * 同步书签到 IndexedDB
   */
  async syncToIndexedDB(bookmarks: BookmarkRecord[]): Promise<Result<void>> {
    try {
      await indexedDBManager.syncBookmarks(bookmarks)
      return { ok: true, value: undefined }
    } catch (error) {
      logger.error('BookmarkRepository', 'Failed to sync bookmarks', error)
      return { ok: false, error: error as Error }
    }
  }
}

// 默认导出单例 (暂时保持兼容)
export const bookmarkRepository = new BookmarkRepository()
```

**示例重构 - bookmark-app-service.ts**:

```typescript
// frontend/src/application/bookmark/bookmark-app-service.ts
/**
 * 书签应用服务
 * 职责：协调多个领域服务，处理应用级用例
 */

import { BookmarkRepository } from '@/core/bookmark/repositories/bookmark-repository'
import { BookmarkTreeService } from '@/core/bookmark/services/tree-service'
import type { Result } from '@/core/common/result'
import type { BookmarkRecord } from '@/infrastructure/indexeddb/schema'

export class BookmarkAppService {
  constructor(
    private bookmarkRepo: BookmarkRepository,
    private treeService: BookmarkTreeService
  ) {}

  /**
   * 获取书签树数据 (用例)
   */
  async getBookmarkTreeData(): Promise<Result<{
    bookmarks: BookmarkRecord[]
    tree: chrome.bookmarks.BookmarkTreeNode[]
  }>> {
    // 1. 从 IndexedDB 获取书签
    const bookmarksResult = await this.bookmarkRepo.getAllBookmarks()
    if (!bookmarksResult.ok) {
      return bookmarksResult
    }

    // 2. 从 Chrome API 获取树
    const treeResult = await this.bookmarkRepo.getBookmarkTree()
    if (!treeResult.ok) {
      return treeResult
    }

    return {
      ok: true,
      value: {
        bookmarks: bookmarksResult.value,
        tree: treeResult.value
      }
    }
  }

  /**
   * 同步书签 (用例)
   */
  async syncBookmarks(): Promise<Result<void>> {
    // 1. 从 Chrome API 获取最新数据
    const treeResult = await this.bookmarkRepo.getBookmarkTree()
    if (!treeResult.ok) {
      return treeResult
    }

    // 2. 转换为扁平结构
    const bookmarks = this.treeService.flattenTree(treeResult.value)

    // 3. 同步到 IndexedDB
    return this.bookmarkRepo.syncToIndexedDB(bookmarks)
  }
}

// 工厂函数
export function createBookmarkAppService(): BookmarkAppService {
  const bookmarkRepo = new BookmarkRepository()
  const treeService = new BookmarkTreeService()
  return new BookmarkAppService(bookmarkRepo, treeService)
}

// 默认导出 (保持兼容)
export const bookmarkAppService = createBookmarkAppService()
```

**桥接层 (临时兼容)**:

```typescript
// frontend/src/utils/unified-bookmark-api.ts (临时保留)
/**
 * @deprecated 请使用 @/application/bookmark/bookmark-app-service
 * 此文件仅用于向后兼容，将在下个版本移除
 */

import { bookmarkAppService } from '@/application/bookmark/bookmark-app-service'

// 重新导出，保持旧 API 可用
export const managementAPI = bookmarkAppService
export const popupAPI = bookmarkAppService
export const sidePanelAPI = bookmarkAppService

// 其他旧 API...
```

---

#### 2.2 更新 import 路径

**手动更新** (如果项目较小):
```typescript
// 旧代码
import { managementAPI } from '@/utils/unified-bookmark-api'

// 新代码
import { bookmarkAppService } from '@/application/bookmark/bookmark-app-service'
```

**自动更新** (推荐 - 使用 VS Code):
1. 在 VS Code 中，右键点击 `unified-bookmark-api.ts`
2. 选择 "Find All References"
3. 批量替换 import 路径

**或使用脚本**:
```bash
# 创建 scripts/update-imports.sh
find frontend/src -type f \( -name "*.ts" -o -name "*.vue" \) \
  -exec sed -i "s|@/utils/unified-bookmark-api|@/application/bookmark/bookmark-app-service|g" {} \;
```

---

#### 2.3 验证迁移

```bash
# 1. 类型检查
cd frontend
npm run type-check

# 2. Lint
npm run lint:check

# 3. 构建
npm run build

# 4. 手动测试关键功能
# - 打开 Management 页面
# - 测试书签加载
# - 测试搜索功能
```

---

### Step 3: 迁移文件 - 第二批 (2-3小时)

#### 3.1 迁移搜索逻辑

```
services/hybrid-search-engine.ts
  → core/search/engine.ts

services/fuse-search.ts
  → core/search/strategies/fuse-strategy.ts

composables/useBookmarkSearch.ts
  → presentation/composables/useBookmarkSearch.ts (精简，只保留UI逻辑)
```

**核心搜索引擎**:

```typescript
// frontend/src/core/search/engine.ts
export interface SearchStrategy {
  search(query: string, bookmarks: Bookmark[]): SearchResult[]
}

export class SearchEngine {
  constructor(private strategy: SearchStrategy) {}

  setStrategy(strategy: SearchStrategy): void {
    this.strategy = strategy
  }

  search(query: string, bookmarks: Bookmark[]): Result<SearchResult[]> {
    try {
      const results = this.strategy.search(query, bookmarks)
      return { ok: true, value: results }
    } catch (error) {
      return { ok: false, error: error as Error }
    }
  }
}
```

**Fuse 搜索策略**:

```typescript
// frontend/src/core/search/strategies/fuse-strategy.ts
import Fuse from 'fuse.js'
import type { SearchStrategy } from '../engine'

export class FuseSearchStrategy implements SearchStrategy {
  search(query: string, bookmarks: Bookmark[]): SearchResult[] {
    const fuse = new Fuse(bookmarks, {
      keys: ['title', 'url', 'tags'],
      threshold: 0.3,
      includeScore: true
    })

    const results = fuse.search(query)
    return results.map(r => ({
      ...r.item,
      score: 1 - (r.score || 0)
    }))
  }
}
```

---

#### 3.2 迁移基础设施

```
utils/indexeddb-manager.ts
  → infrastructure/indexeddb/manager.ts

utils/chrome-api.ts
  → infrastructure/chrome-api/wrapper.ts

utils/logger.ts
  → infrastructure/logging/logger.ts
```

---

### Step 4: 精简 Store (2小时)

**当前问题**: Store 包含太多业务逻辑

**目标**: Store 只负责 UI 状态管理

**重构 management-store.ts**:

```typescript
// frontend/src/stores/management-store.ts (重构后)
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { bookmarkAppService } from '@/application/bookmark/bookmark-app-service'
import type { BookmarkNode } from '@/types'

export const useManagementStore = defineStore('management', () => {
  // ========== 状态 (只保留UI状态) ==========
  const originalTree = ref<BookmarkNode[]>([])
  const proposalTree = ref<BookmarkNode | null>(null)
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const structuresAreDifferent = ref(false)

  // ========== 计算属性 ==========
  const hasProposal = computed(() => proposalTree.value !== null)
  const canSave = computed(() => structuresAreDifferent.value && hasProposal.value)

  // ========== 操作 (委托给应用服务) ==========
  async function loadData() {
    isLoading.value = true
    error.value = null

    const result = await bookmarkAppService.getBookmarkTreeData()

    if (result.ok) {
      originalTree.value = result.value.tree
    } else {
      error.value = result.error.message
    }

    isLoading.value = false
  }

  function compareStructures() {
    // 委托给服务
    // structuresAreDifferent.value = ...
  }

  return {
    // 状态
    originalTree,
    proposalTree,
    isLoading,
    error,
    structuresAreDifferent,
    // 计算
    hasProposal,
    canSave,
    // 操作
    loadData,
    compareStructures
  }
})
```

---

### Step 5: 清理和文档 (1小时)

#### 5.1 移除旧文件

```bash
# 确认新代码稳定后，删除旧文件
# ⚠️ 谨慎操作，建议先备份

# 删除已迁移的文件
rm frontend/src/utils/unified-bookmark-api.ts
rm frontend/src/utils/smart-bookmark-manager.ts
# ...

# 或者先移到临时目录观察
mkdir -p frontend/src/_deprecated
mv frontend/src/utils/unified-bookmark-api.ts frontend/src/_deprecated/
```

#### 5.2 更新文档

```markdown
# 更新 README.md

## 目录结构

```
frontend/src/
├── core/              # 核心业务逻辑 (框架无关)
│   ├── bookmark/      # 书签领域
│   └── search/        # 搜索领域
├── infrastructure/    # 基础设施 (可替换)
│   ├── indexeddb/
│   ├── chrome-api/
│   └── logging/
├── application/       # 应用服务 (用例编排)
│   ├── bookmark/
│   └── search/
├── presentation/      # 表现层 (UI)
│   ├── stores/
│   ├── composables/
│   └── components/
└── utils/            # 纯工具函数
```
```

#### 5.3 添加迁移指南

创建 `MIGRATION.md`:

```markdown
# 迁移指南

## 从旧 API 迁移到新架构

### 书签 API

**旧代码**:
\`\`\`typescript
import { managementAPI } from '@/utils/unified-bookmark-api'
const data = await managementAPI.getBookmarkTreeData()
\`\`\`

**新代码**:
\`\`\`typescript
import { bookmarkAppService } from '@/application/bookmark/bookmark-app-service'
const result = await bookmarkAppService.getBookmarkTreeData()
if (result.ok) {
  const data = result.value
}
\`\`\`

### 搜索 API

**旧代码**:
\`\`\`typescript
import { bookmarkSearchService } from '@/services/hybrid-search-engine'
const results = await bookmarkSearchService.search(query)
\`\`\`

**新代码**:
\`\`\`typescript
import { searchEngine } from '@/core/search/engine'
import { FuseSearchStrategy } from '@/core/search/strategies/fuse-strategy'

const engine = new SearchEngine(new FuseSearchStrategy())
const result = engine.search(query, bookmarks)
if (result.ok) {
  const results = result.value
}
\`\`\`
```

---

## 🎯 阶段二：统一接口和错误处理 (1-2周)

### Step 1: 定义 Result 类型 (30分钟)

```typescript
// frontend/src/core/common/result.ts
export type Result<T, E = Error> = 
  | { ok: true; value: T }
  | { ok: false; error: E }

export namespace Result {
  export function ok<T>(value: T): Result<T> {
    return { ok: true, value }
  }
  
  export function err<E = Error>(error: E): Result<never, E> {
    return { ok: false, error }
  }
  
  export function isOk<T, E>(result: Result<T, E>): result is { ok: true; value: T } {
    return result.ok === true
  }
  
  export function isErr<T, E>(result: Result<T, E>): result is { ok: false; error: E } {
    return result.ok === false
  }
}
```

### Step 2: 更新所有 async 函数 (渐进式)

**策略**: 从最底层开始，逐层往上更新

1. Infrastructure 层先改
2. Core 层其次
3. Application 层跟上
4. Presentation 层最后

**示例**:

```typescript
// 改前
async function loadBookmarks(): Promise<Bookmark[]> {
  return await db.getAll()
}

// 改后
async function loadBookmarks(): Promise<Result<Bookmark[]>> {
  try {
    const data = await db.getAll()
    return Result.ok(data)
  } catch (error) {
    return Result.err(error as Error)
  }
}
```

---

## 📊 进度跟踪

### 阶段一检查清单

- [ ] 创建新目录结构
- [ ] 迁移 unified-bookmark-api.ts
- [ ] 迁移 smart-bookmark-*.ts
- [ ] 迁移搜索相关文件
- [ ] 迁移基础设施文件
- [ ] 精简 management-store.ts
- [ ] 精简 popup-store.ts
- [ ] 更新所有 import 路径
- [ ] 运行类型检查 ✅
- [ ] 运行 Lint ✅
- [ ] 构建成功 ✅
- [ ] 手动测试关键功能 ✅
- [ ] 更新文档
- [ ] 清理旧文件

### 阶段二检查清单

- [ ] 定义 Result 类型
- [ ] 更新 infrastructure 层
- [ ] 更新 core 层
- [ ] 更新 application 层
- [ ] 更新 presentation 层
- [ ] 统一错误日志
- [ ] 更新测试代码

---

## ⚠️ 风险管理

### 常见问题

**Q: 重构后构建失败？**
A: 检查 import 路径是否正确，使用 VS Code 的 "Organize Imports" 功能

**Q: 类型检查报错？**
A: 确保新文件的类型定义与旧文件兼容，必要时添加类型断言

**Q: 运行时错误？**
A: 检查是否有循环依赖，使用延迟导入或依赖注入解决

**Q: 性能下降？**
A: 确认是否引入了不必要的计算，使用 Performance 工具分析

### 回滚策略

如果重构出现严重问题：

```bash
# 方案1: Git 回滚
git reset --hard HEAD~1

# 方案2: 使用备份
cp -r frontend/src/_backup/* frontend/src/

# 方案3: 使用 Git stash
git stash
# 修复问题后
git stash pop
```

---

## 🎉 成功标准

### 阶段一完成标准
- ✅ 所有文件按分层架构重新组织
- ✅ import 路径全部更新
- ✅ 类型检查无错误
- ✅ Lint 无警告
- ✅ 构建成功
- ✅ 核心功能测试通过
- ✅ 文档已更新

### 整体优化完成标准
- ✅ 代码组织清晰，职责明确
- ✅ 错误处理统一
- ✅ 搜索系统统一
- ✅ Store 精简
- ✅ 可测试性提升 50%
- ✅ 新人上手时间减少 40%

---

**下一步**: 开始执行阶段一第一步，创建新目录结构！ 🚀
