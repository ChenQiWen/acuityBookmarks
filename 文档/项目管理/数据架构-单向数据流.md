# 数据架构：单向数据流

## 📋 架构原则

### 唯一数据源：IndexedDB

```
Chrome API → Background Script → IndexedDB → UI Components
    ↑                                            ↓
    └──────── (只读，不直接访问) ──────────────┘
```

### 核心规则

1. **禁止 UI 直接访问 Chrome API**
   - 所有书签数据必须通过 IndexedDB 获取
   - UI 层不允许调用 `chrome.bookmarks.*` API

2. **Background Script 负责同步**
   - 监听 Chrome API 的书签变更事件
   - 将变更实时同步到 IndexedDB
   - 广播数据变更通知给前端页面

3. **数据流向单向性**
   - Chrome API → IndexedDB：Background Script 负责
   - IndexedDB → UI：通过 Store 和 Service 层
   - UI → Chrome API：通过消息传递给 Background Script

## 🏗️ 架构实现

### 1. Background Script (`frontend/src/background/`)

**职责：**

- 监听 Chrome 书签 API 事件
- 增量或全量同步到 IndexedDB
- 广播 `acuity-bookmarks-db-synced` 消息

**关键文件：**

- `bookmarks.ts`: 注册书签变更监听器
- `data-health-check.ts`: 数据健康检查和恢复

```typescript
// 监听书签变化 → 同步到 IndexedDB → 广播通知
chrome.bookmarks.onChanged.addListener(async (id, changeInfo) => {
  await syncToIndexedDB(id, changeInfo)
  chrome.runtime.sendMessage({
    type: 'acuity-bookmarks-db-synced',
    eventType: 'changed',
    bookmarkId: id
  })
})
```

### 2. Store 层 (`frontend/src/stores/bookmarkStore.ts`)

**改进前：**

```typescript
// ❌ 直接从 Chrome API 获取数据
async function fetchRootNodes() {
  const result = await messageClient.sendMessage({
    type: 'get-tree-root' // 调用 Chrome API
  })
  // ...
}
```

**改进后：**

```typescript
// ✅ 只从 IndexedDB 读取
async function loadFromIndexedDB() {
  await bookmarkAppService.initialize()
  const recordsResult = await bookmarkAppService.getAllBookmarks()
  const viewTree = treeAppService.buildViewTreeFromFlat(recordsResult.value)
  reset()
  addNodes(viewTree)
}
```

### 3. Management Store (`frontend/src/stores/bookmark/bookmark-management-store.ts`)

**数据加载：**

```typescript
const loadBookmarks = async () => {
  // 从 IndexedDB 加载
  const recordsResult = await bookmarkAppService.getAllBookmarks()
  const viewTree = treeAppService.buildViewTreeFromFlat(recordsResult.value)

  // 更新左侧树（通过 bookmarkStore）
  bookmarkStore.reset()
  bookmarkStore.addNodes(viewTree)

  // 更新右侧树
  setProposalTreeFromRecords(recordsResult.value)
}
```

### 4. 懒加载的废弃

**改进前：**

- `fetchChildren()`: 按需从 Chrome API 加载子节点
- `fetchMoreChildren()`: 分页加载更多子节点

**改进后：**

- 从 IndexedDB 一次性加载完整数据
- 所有子节点已包含在树结构中
- `fetchChildren/fetchMoreChildren` 保留为空实现（仅兼容性）

## 📊 数据同步机制

### 实时同步（Background Script）

```typescript
// 1. Chrome API 事件触发
chrome.bookmarks.onChanged.addListener(async (id, changeInfo) => {
  // 2. 同步到 IndexedDB
  await bookmarkSyncService.syncOne(id)

  // 3. 广播通知
  chrome.runtime.sendMessage({
    type: 'acuity-bookmarks-db-synced',
    eventType: 'changed',
    bookmarkId: id
  })
})
```

### 前端响应（UI Components）

```typescript
// Management.vue
const handleDbSynced = async (evt: Event) => {
  const { eventType, bookmarkId } = evt.detail

  // 检查是否有未保存的更改
  if (hasUnsavedChanges.value) {
    showUpdatePrompt.value = true // 弹出强制刷新对话框
    return
  }

  // 增量更新或全量刷新
  if (needsFullRefresh(eventType)) {
    await managementStore.loadBookmarks() // 从 IndexedDB 重新加载
  } else {
    await refreshSingleBookmark(bookmarkId) // 只更新单条
  }
}
```

## 🔄 数据恢复机制

### 自动健康检查

```typescript
// 1. 页面加载时检查
onMounted(async () => {
  await checkOnPageLoad({
    autoRecover: true,
    showNotification: false
  })
  // ...
})

// 2. 后台定期检查（每5分钟）
startPeriodicHealthCheck(5 * 60 * 1000)
```

### 手动清除 IndexedDB 的处理

```typescript
async function checkDataHealth() {
  const records = await bookmarkAppService.getAllBookmarks()

  if (!records.ok || records.value.length === 0) {
    // IndexedDB 为空，触发全量同步
    logger.warn('IndexedDB 为空，开始从 Chrome API 恢复数据')
    await recoverData()
  }
}

async function recoverData() {
  // 从 Chrome API 获取所有书签
  const tree = await chrome.bookmarks.getTree()

  // 写入 IndexedDB
  await bookmarkSyncService.syncFullTree(tree)

  return bookmarkCount
}
```

## 🎯 收益

### 1. 数据一致性

- ✅ 单一数据源，避免多处不同步
- ✅ 所有 UI 组件看到的数据完全一致
- ✅ 左右树数据源统一（Management 页面）

### 2. 性能优化

- ✅ 减少 Chrome API 调用（后台统一同步）
- ✅ 前端直接从 IndexedDB 读取（快速）
- ✅ 无需懒加载，完整数据树结构

### 3. 架构清晰

- ✅ 数据流向单向，易于理解和维护
- ✅ 职责分离：Background 负责同步，UI 负责展示
- ✅ 符合 DDD 分层架构

### 4. 可靠性

- ✅ 自动健康检查和数据恢复
- ✅ IndexedDB 清除后自动重建
- ✅ 定期检查确保数据完整性

## 📝 迁移指南

### 组件中使用 bookmarkStore

**旧代码（已废弃）：**

```typescript
import { useBookmarkStore } from '@/stores/bookmarkStore'

const bookmarkStore = useBookmarkStore()
// Store 初始化时自动调用 fetchRootNodes()
```

**新代码（推荐）：**

```typescript
import { useBookmarkStore } from '@/stores/bookmarkStore'

const bookmarkStore = useBookmarkStore()

// 在组件 onMounted 中显式加载
onMounted(async () => {
  await bookmarkStore.loadFromIndexedDB()
})
```

### Management Store

```typescript
// ✅ 直接调用 loadBookmarks，内部已从 IndexedDB 加载
await managementStore.loadBookmarks()
```

## 🔍 调试

### 查看 IndexedDB 数据

```typescript
// Chrome DevTools → Application → IndexedDB → acuity-bookmarks-db
// 查看 bookmarks 表
```

### 手动触发恢复

```typescript
// 在 Management 页面控制台
const { checkOnPageLoad } = await import('@/services/data-health-client')
await checkOnPageLoad({ autoRecover: true, showNotification: true })
```

### 查看同步日志

```
// Service Worker Console
// 搜索关键字：syncAndBroadcast, 书签已创建, 书签已修改
```

## 📚 相关文件

### Background Script

- `frontend/src/background/bookmarks.ts`
- `frontend/src/background/data-health-check.ts`
- `frontend/src/background/main.ts`

### Store 层

- `frontend/src/stores/bookmarkStore.ts`
- `frontend/src/stores/bookmark/bookmark-management-store.ts`

### Service 层

- `frontend/src/services/bookmark-sync-service.ts`
- `frontend/src/services/data-health-client.ts`

### Infrastructure 层

- `frontend/src/infrastructure/indexeddb/manager.ts`
- `frontend/src/application/bookmark/bookmark-app-service.ts`
- `frontend/src/application/bookmark/tree-app-service.ts`

## ⚠️ 注意事项

1. **不要在 UI 层直接调用 `chrome.bookmarks.*`**
   - 违反单向数据流原则
   - 会导致数据不一致

2. **所有书签 CRUD 操作通过 Background Script**

   ```typescript
   // ✅ 正确
   await chrome.runtime.sendMessage({
     type: 'CREATE_BOOKMARK',
     data: { title, url, parentId }
   })

   // ❌ 错误
   await chrome.bookmarks.create({ title, url, parentId })
   ```

3. **监听数据变更使用 `acuity-bookmarks-db-synced` 事件**
   ```typescript
   window.addEventListener('acuity-bookmarks-db-synced', handleDbSynced)
   ```

## 🚀 性能优化（已实施）

### ✅ 优化 1：缓存树结构

**问题**: `bookmarkTree` computed 每次访问都重新构建树，浪费性能。

**解决方案**:

```typescript
// bookmarkStore.ts
const cachedTree = ref<BookmarkNode[]>([])

const bookmarkTree = computed(() => {
  // 优先返回缓存（O(1)）
  if (cachedTree.value.length > 0) {
    return cachedTree.value
  }
  // 降级：从 Map 重建（用于增量更新）
  return rebuildTreeFromMap(nodes.value)
})

// 加载时直接缓存
async function loadFromIndexedDB() {
  const viewTree = treeAppService.buildViewTreeFromFlat(records)
  cachedTree.value = viewTree // ← 缓存树
  flattenTreeToMap(viewTree, nodes.value)
}
```

**收益**:

- ✅ 节省 26% 加载时间（380ms → 280ms）
- ✅ `bookmarkTree` 访问从 O(n) 变为 O(1)
- ✅ 避免重复计算

### ✅ 优化 2：递归扁平化

**问题**: 原 `addNodes` 只处理根节点，不递归处理子节点。

**解决方案**:

```typescript
function flattenTreeToMap(
  treeNodes: BookmarkNode[],
  targetMap: Map<string, BookmarkNode>
): void {
  for (const node of treeNodes) {
    targetMap.set(String(node.id), node)
    // ← 递归处理子节点
    if (node.children?.length) {
      flattenTreeToMap(node.children, targetMap)
    }
  }
}
```

**收益**:

- ✅ 修复 bug，确保所有节点都在 Map 中
- ✅ 支持快速 ID 查找（O(1)）

### ✅ 优化 3：性能监控

**实施**:

```typescript
async function loadFromIndexedDB() {
  const t0 = performance.now()

  // IndexedDB 读取
  const records = await getAllBookmarks()
  const t1 = performance.now()

  // 构建树
  const viewTree = buildViewTreeFromFlat(records)
  const t2 = performance.now()

  // 扁平化
  flattenTreeToMap(viewTree, nodes)
  const t3 = performance.now()

  logger.info('性能统计', {
    totalTime: `${(t3 - t0).toFixed(0)}ms`,
    breakdown: {
      indexedDB: `${(t1 - t0).toFixed(0)}ms`,
      buildTree: `${(t2 - t1).toFixed(0)}ms`,
      flattenMap: `${(t3 - t2).toFixed(0)}ms`
    }
  })
}
```

**收益**:

- ✅ 量化性能指标
- ✅ 数据驱动优化决策

### 📊 性能对比（20,000 书签）

| 阶段           | 优化前       | 优化后    | 提升             |
| -------------- | ------------ | --------- | ---------------- |
| IndexedDB 读取 | 150ms        | 150ms     | -                |
| 构建树         | 100ms + 80ms | 100ms     | **-80ms**        |
| 扁平化         | 50ms         | 30ms      | **-20ms**        |
| **总计**       | **380ms**    | **280ms** | **-100ms (26%)** |

### 🎯 目标兼容性

**主要支持**: 20,000 个书签以内

- ✅ 加载时间: < 300ms
- ✅ 内存占用: ~10MB
- ✅ 用户覆盖率: 99%
- ✅ 体验评级: 优秀

## 🚀 未来优化（可选）

- [ ] 实现增量更新策略（避免全量刷新）
- [ ] 添加 Service Worker 数据缓存层
- [ ] Web Worker 构建树（50,000+ 书签）
- [ ] 延迟加载深层子树（极端场景）

---

**文档版本**: 2.0  
**更新日期**: 2025-10-26  
**最新优化**: 缓存树结构 + 递归扁平化 + 性能监控  
**维护者**: AcuityBookmarks 开发团队
