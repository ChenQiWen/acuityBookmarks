# 本地化爬取系统 - 集成指南

## 🎯 快速开始

### 1. 配置环境变量

在 `.env` 文件中设置：

```bash
# 强制使用本地模式（关键！）
VITE_CRAWLER_MODE=local

# 并发控制
VITE_CRAWLER_CONCURRENCY=2
VITE_CRAWLER_PER_DOMAIN_CONCURRENCY=1

# 批量处理
VITE_CRAWLER_BATCH_SIZE=5
VITE_CRAWLER_BATCH_INTERVAL_MS=1500

# 启用空闲调度
VITE_CRAWLER_USE_IDLE_SCHEDULING=true
VITE_CRAWLER_IDLE_DELAY_MS=3000

# 尊重 Robots.txt
VITE_CRAWLER_RESPECT_ROBOTS=true
```

### 2. 导入组件

```typescript
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'
import { warmupOffscreenDocument } from '@/services/local-crawler-worker'
```

### 3. 基本使用

```typescript
// 预热 Offscreen Document（可选，但推荐）
await warmupOffscreenDocument()

// 获取所有书签
const bookmarks = await getAllBookmarks()

// 调度爬取任务
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  priority: 'normal',
  respectRobots: true,

  onProgress: stats => {
    console.log(`进度: ${stats.progress}% (${stats.completed}/${stats.total})`)
  },

  onTaskComplete: task => {
    if (task.result?.success) {
      console.log(`✅ 完成: ${task.url}`)
      // 更新 UI、缓存等
    }
  },

  onComplete: stats => {
    console.log('🎉 全部完成!', stats)
  }
})
```

---

## 📖 详细示例

### 示例1: Management 页面 - 批量刷新元数据

```typescript
// frontend/src/components/management/MetadataRefreshButton.vue

<template>
  <div class="metadata-refresh">
    <button
      @click="handleRefresh"
      :disabled="isRefreshing"
      class="btn-refresh"
    >
      <span v-if="!isRefreshing">🔄 刷新所有书签元数据</span>
      <span v-else>⏳ 刷新中... {{ progress }}%</span>
    </button>

    <div v-if="isRefreshing" class="progress-panel">
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: progress + '%' }"></div>
      </div>

      <div class="stats">
        <span>总数: {{ stats.total }}</span>
        <span>完成: {{ stats.completed }}</span>
        <span>失败: {{ stats.failed }}</span>
        <span>待处理: {{ stats.pending }}</span>
      </div>

      <div class="controls">
        <button @click="handlePause" v-if="!isPaused">⏸️ 暂停</button>
        <button @click="handleResume" v-else>▶️ 继续</button>
        <button @click="handleCancel">❌ 取消</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'
import type { QueueStatistics } from '@/services/crawl-task-scheduler'
import { useBookmarkStore } from '@/stores/bookmark-store'
import { useNotificationStore } from '@/stores/notification-store'

const bookmarkStore = useBookmarkStore()
const notificationStore = useNotificationStore()

const isRefreshing = ref(false)
const isPaused = ref(false)
const stats = ref<QueueStatistics>({
  total: 0,
  completed: 0,
  failed: 0,
  pending: 0,
  running: 0,
  paused: 0,
  progress: 0
})

const progress = computed(() => stats.value.progress)

async function handleRefresh() {
  // 1. 获取所有书签
  const allBookmarks = await bookmarkStore.getAllBookmarks()
  const urlBookmarks = allBookmarks.filter(b => b.url && !b.url.startsWith('chrome://'))

  if (urlBookmarks.length === 0) {
    notificationStore.show({
      message: '没有可爬取的书签',
      type: 'warning'
    })
    return
  }

  // 2. 确认对话框
  const estimatedTime = Math.ceil((urlBookmarks.length / 2) * 2 / 60) // 粗略估计
  const confirmed = confirm(
    `将在后台爬取 ${urlBookmarks.length} 个书签的元数据\n` +
    `预计需要约 ${estimatedTime} 分钟\n` +
    `是否继续？`
  )

  if (!confirmed) return

  // 3. 开始刷新
  isRefreshing.value = true
  isPaused.value = false

  try {
    await crawlTaskScheduler.scheduleBookmarksCrawl(urlBookmarks, {
      priority: 'normal',
      respectRobots: true,

      onProgress: (newStats) => {
        stats.value = newStats
      },

      onTaskComplete: async (task) => {
        if (task.result?.success && task.result.metadata) {
          // 更新书签元数据
          await bookmarkStore.updateBookmarkMetadata(task.bookmarkId, {
            title: task.result.metadata.title || task.bookmarkTitle,
            description: task.result.metadata.description,
            keywords: task.result.metadata.keywords,
            // ... 其他字段
          })
        }
      },

      onComplete: (finalStats) => {
        notificationStore.show({
          message: `元数据刷新完成！成功: ${finalStats.completed}, 失败: ${finalStats.failed}`,
          type: 'success'
        })

        isRefreshing.value = false
      },

      onError: (error) => {
        notificationStore.show({
          message: `刷新出错: ${error.message}`,
          type: 'error'
        })

        isRefreshing.value = false
      }
    })
  } catch (error) {
    console.error('刷新元数据失败:', error)
    notificationStore.show({
      message: '启动刷新失败',
      type: 'error'
    })

    isRefreshing.value = false
  }
}

function handlePause() {
  crawlTaskScheduler.pause()
  isPaused.value = true
}

function handleResume() {
  crawlTaskScheduler.resume()
  isPaused.value = false
}

async function handleCancel() {
  const confirmed = confirm('确定要取消刷新吗？')
  if (confirmed) {
    await crawlTaskScheduler.cancelAll()
    isRefreshing.value = false
    isPaused.value = false
  }
}
</script>

<style scoped>
.metadata-refresh {
  padding: 1rem;
}

.btn-refresh {
  padding: 0.5rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background: #4285f4;
  color: white;
  transition: background 0.2s;
}

.btn-refresh:hover:not(:disabled) {
  background: #357ae8;
}

.btn-refresh:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.progress-panel {
  margin-top: 1rem;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #eee;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #4285f4;
  transition: width 0.3s;
}

.stats {
  margin-top: 1rem;
  display: flex;
  gap: 1rem;
  font-size: 0.9rem;
}

.controls {
  margin-top: 1rem;
  display: flex;
  gap: 0.5rem;
}

.controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.9rem;
  cursor: pointer;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

.controls button:hover {
  background: #f5f5f5;
}
</style>
```

---

### 示例2: 新增书签时自动爬取

```typescript
// frontend/src/services/bookmark-auto-crawl.ts

import { crawlTaskScheduler } from './crawl-task-scheduler'
import { lightweightBookmarkEnhancer } from './lightweight-bookmark-enhancer'
import { logger } from '@/infrastructure/logging/logger'

/**
 * 监听书签创建事件，自动爬取元数据
 */
export function setupAutoBookmarkCrawl() {
  chrome.bookmarks.onCreated.addListener(async (id, bookmark) => {
    // 只处理 URL 书签
    if (!bookmark.url || bookmark.url.startsWith('chrome://')) {
      return
    }

    logger.info('AutoCrawl', `📌 新书签创建: ${bookmark.url}`)

    try {
      // 方式1: 立即爬取（高优先级）
      await crawlTaskScheduler.scheduleBookmarksCrawl([bookmark], {
        priority: 'high',
        onTaskComplete: async task => {
          if (task.result?.success && task.result.metadata) {
            // 保存元数据到缓存
            await lightweightBookmarkEnhancer.saveMetadata({
              bookmarkId: id,
              url: bookmark.url!,
              title: task.result.metadata.title || bookmark.title || '',
              ...task.result.metadata
            })

            logger.info('AutoCrawl', `✅ 新书签元数据已获取: ${bookmark.url}`)
          }
        }
      })
    } catch (error) {
      logger.error('AutoCrawl', '新书签爬取失败', error)
    }
  })

  logger.info('AutoCrawl', '✅ 自动爬取已启用')
}
```

---

### 示例3: Background Script 初始化

```typescript
// frontend/background.js

import { setupAutoBookmarkCrawl } from './src/services/bookmark-auto-crawl'
import { warmupOffscreenDocument } from './src/services/local-crawler-worker'
import { crawlTaskScheduler } from './src/services/crawl-task-scheduler'

// 扩展安装/更新时
chrome.runtime.onInstalled.addListener(async details => {
  if (details.reason === 'install') {
    console.log('🎉 AcuityBookmarks 已安装')

    // 预热 Offscreen Document
    await warmupOffscreenDocument()

    // 启动自动爬取
    setupAutoBookmarkCrawl()

    // 显示欢迎页面
    chrome.tabs.create({ url: 'management.html' })
  }

  if (details.reason === 'update') {
    console.log('🔄 AcuityBookmarks 已更新')

    // 预热 Offscreen Document
    await warmupOffscreenDocument()
  }
})

// 扩展启动时
chrome.runtime.onStartup.addListener(async () => {
  console.log('🚀 AcuityBookmarks 已启动')

  // 预热 Offscreen Document
  await warmupOffscreenDocument()

  // 启动自动爬取
  setupAutoBookmarkCrawl()

  // 恢复中断的爬取任务
  const stats = crawlTaskScheduler.getStatistics()
  if (stats.pending > 0) {
    console.log(`📂 恢复 ${stats.pending} 个待处理任务`)
    crawlTaskScheduler.resume()
  }
})
```

---

### 示例4: 定期后台刷新

```typescript
// frontend/src/services/background-refresh.ts

import { crawlTaskScheduler } from './crawl-task-scheduler'
import { indexedDBManager } from '@/infrastructure/indexeddb/manager'
import { logger } from '@/infrastructure/logging/logger'

/**
 * 设置定期后台刷新
 */
export function setupBackgroundRefresh() {
  // 每天凌晨2点刷新一次过期的书签
  chrome.alarms.create('refresh-expired-bookmarks', {
    when: getNextMidnight(),
    periodInMinutes: 24 * 60 // 每24小时
  })

  chrome.alarms.onAlarm.addListener(async alarm => {
    if (alarm.name === 'refresh-expired-bookmarks') {
      await refreshExpiredBookmarks()
    }
  })

  logger.info('BackgroundRefresh', '✅ 定期刷新已设置')
}

/**
 * 刷新过期的书签元数据
 */
async function refreshExpiredBookmarks() {
  try {
    logger.info('BackgroundRefresh', '🔄 开始刷新过期书签')

    // 1. 获取所有过期的书签
    const expiredBookmarks = await indexedDBManager.getExpiredBookmarks()

    if (expiredBookmarks.length === 0) {
      logger.info('BackgroundRefresh', '✅ 没有过期书签需要刷新')
      return
    }

    logger.info(
      'BackgroundRefresh',
      `📋 发现 ${expiredBookmarks.length} 个过期书签`
    )

    // 2. 调度刷新任务（低优先级，不影响用户）
    await crawlTaskScheduler.scheduleBookmarksCrawl(expiredBookmarks, {
      priority: 'low',
      respectRobots: true,

      onComplete: stats => {
        logger.info('BackgroundRefresh', '✅ 后台刷新完成', stats)

        // 发送通知（可选）
        if (stats.completed > 0) {
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'images/icon128.png',
            title: 'AcuityBookmarks',
            message: `已刷新 ${stats.completed} 个书签的元数据`
          })
        }
      }
    })
  } catch (error) {
    logger.error('BackgroundRefresh', '后台刷新失败', error)
  }
}

/**
 * 获取下次凌晨2点的时间戳
 */
function getNextMidnight(): number {
  const now = new Date()
  const next = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate() + 1,
    2, // 凌晨2点
    0,
    0
  )
  return next.getTime()
}
```

---

## 🔧 修改现有代码

### 1. 修改 `lightweight-bookmark-enhancer.ts`

将 Serverless 爬取改为本地爬取：

```typescript
// 找到 crawlAndCache 方法，修改如下：

private async crawlAndCache(
  bookmark: chrome.bookmarks.BookmarkTreeNode
): Promise<LightweightBookmarkMetadata> {
  const startTime = Date.now()
  logger.info('LightweightEnhancer', `🚀 开始爬取: ${bookmark.url}`)

  try {
    if (!bookmark.url) {
      throw new Error(`书签URL为空: ${bookmark.id}`)
    }

    // 后台空闲调度
    await this.deferForIdleIfNeeded()

    // ✅ 使用新的本地爬虫（移除 Serverless 调用）
    const result = await crawlBookmarkLocally(bookmark.url, {
      respectRobots: true,
      timeout: 10000
    })

    if (!result.success || !result.metadata) {
      throw new Error(result.error || '爬取失败')
    }

    // 构建元数据对象
    const metadata: LightweightBookmarkMetadata = {
      // Chrome 字段
      id: bookmark.id,
      url: bookmark.url,
      title: bookmark.title || '',
      dateAdded: bookmark.dateAdded,
      dateLastUsed: bookmark.dateLastUsed,
      parentId: bookmark.parentId,

      // 爬取字段
      extractedTitle: result.metadata.title,
      description: result.metadata.description,
      keywords: result.metadata.keywords,
      ogTitle: result.metadata.ogTitle,
      ogDescription: result.metadata.ogDescription,
      ogImage: result.metadata.ogImage,
      ogSiteName: result.metadata.ogSiteName,

      // 缓存字段
      lastCrawled: Date.now(),
      crawlSuccess: true,
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,
      crawlCount: 1,
      finalUrl: result.url,
      lastModified: new Date().toISOString(),

      // 状态字段
      crawlStatus: {
        lastCrawled: Date.now(),
        status: 'success',
        crawlDuration: result.duration,
        version: 2,
        source: 'local-crawler',
        finalUrl: result.url,
        httpStatus: result.httpStatus
      }
    }

    // 保存到缓存
    await this.saveToCacheInternal(metadata)
    await this.saveToUnifiedIndexedDB(metadata)
    await this.incrementDailyCounter()

    logger.info(
      'LightweightEnhancer',
      `✅ 爬取成功: ${bookmark.url} (${Date.now() - startTime}ms)`
    )

    return metadata
  } catch (error) {
    logger.error('LightweightEnhancer', `❌ 爬取失败: ${bookmark.url}`, error)
    // ... 错误处理
  }
}
```

### 2. 移除 Serverless 依赖

```typescript
// 移除这些导入（如果存在）
// import { serverlessCrawlerClient } from './serverless-crawler-client'
// import { API_CONFIG } from '@/config/constants'

// 添加新的导入
import { crawlBookmarkLocally } from './local-crawler-worker'
```

---

## 🎯 最佳实践

### 1. 预热 Offscreen Document

在应用启动时预热，避免首次爬取延迟：

```typescript
// 在 main.ts 或 background.js 中
import { warmupOffscreenDocument } from '@/services/local-crawler-worker'

// 应用初始化时
warmupOffscreenDocument()
```

### 2. 使用合适的优先级

```typescript
// 用户手动触发 → 高优先级
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  priority: 'high' // 或 'urgent'
})

// 新增书签自动爬取 → 普通优先级
await crawlTaskScheduler.scheduleBookmarksCrawl([bookmark], {
  priority: 'normal'
})

// 后台定期刷新 → 低优先级
await crawlTaskScheduler.scheduleBookmarksCrawl(expiredBookmarks, {
  priority: 'low'
})
```

### 3. 渐进式数据呈现

```typescript
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  onTaskComplete: async task => {
    if (task.result?.success) {
      // 立即更新 UI（不等待全部完成）
      await updateBookmarkInUI(task.bookmarkId, task.result.metadata)
    }
  }
})
```

### 4. 错误处理

```typescript
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  onTaskComplete: task => {
    if (task.status === 'failed') {
      // 记录失败原因
      logger.warn('Crawl', `失败: ${task.url}`, task.error)

      // 可以选择性地重新调度
      if (task.error?.includes('timeout')) {
        // 稍后重试超时任务
      }
    }
  }
})
```

### 5. 性能监控

```typescript
import { getCrawlerStats } from '@/services/local-crawler-worker'

// 定期检查
setInterval(() => {
  const stats = getCrawlerStats()
  const queueStats = crawlTaskScheduler.getStatistics()

  console.log('爬虫状态:', {
    缓存域名数: stats.domainsCached,
    Robots缓存数: stats.robotsCached,
    队列进度: `${queueStats.progress}%`,
    运行中任务: queueStats.running
  })
}, 60000) // 每分钟
```

---

## 🧪 测试

### 单元测试

```typescript
// __tests__/local-crawler-worker.test.ts

import { describe, it, expect, vi } from 'vitest'
import { crawlBookmarkLocally } from '@/services/local-crawler-worker'

describe('LocalCrawlerWorker', () => {
  it('should crawl a valid URL successfully', async () => {
    const result = await crawlBookmarkLocally('https://example.com')

    expect(result.success).toBe(true)
    expect(result.metadata).toBeDefined()
    expect(result.metadata?.title).toBeTruthy()
  })

  it('should respect robots.txt', async () => {
    const result = await crawlBookmarkLocally('https://blocked-site.com', {
      respectRobots: true
    })

    if (!result.success && result.errorType === 'robots') {
      expect(result.robotsAllowed).toBe(false)
    }
  })

  it('should handle timeout', async () => {
    const result = await crawlBookmarkLocally('https://slow-site.com', {
      timeout: 100 // 很短的超时
    })

    if (!result.success) {
      expect(result.errorType).toBe('timeout')
    }
  }, 10000)
})
```

### 集成测试

```typescript
// __tests__/crawl-task-scheduler.test.ts

import { describe, it, expect } from 'vitest'
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'

describe('CrawlTaskScheduler', () => {
  it('should schedule and execute bookmark crawl', async () => {
    const testBookmarks = [
      {
        id: '1',
        title: 'Test 1',
        url: 'https://example.com',
        dateAdded: Date.now()
      },
      {
        id: '2',
        title: 'Test 2',
        url: 'https://example.org',
        dateAdded: Date.now()
      }
    ]

    let completedCount = 0

    await crawlTaskScheduler.scheduleBookmarksCrawl(testBookmarks, {
      priority: 'high',
      onTaskComplete: () => {
        completedCount++
      }
    })

    // 等待完成
    await new Promise(resolve => setTimeout(resolve, 10000))

    const stats = crawlTaskScheduler.getStatistics()
    expect(stats.completed + stats.failed).toBe(testBookmarks.length)
  }, 30000)
})
```

---

## 📊 性能预期

### 1000条书签的预期表现

| 指标             | 值       |
| ---------------- | -------- |
| URL去重后        | ~700条   |
| 缓存命中（30天） | ~80%     |
| 实际需爬取       | ~140条   |
| 平均单次耗时     | 2秒      |
| 并发数           | 2        |
| 总耗时           | ~2.5分钟 |
| 内存占用         | <50MB    |
| CPU占用          | <5%      |

### 用户体验

- ✅ **零阻塞**：后台静默执行
- ✅ **实时反馈**：渐进式数据呈现
- ✅ **可控制**：暂停/继续/取消
- ✅ **可恢复**：断点续爬
- ✅ **隐私安全**：100%本地执行

---

## 🔍 故障排查

### 问题1: Offscreen Document 创建失败

**症状**: 控制台显示 "无法创建 Offscreen Document"

**原因**:

- manifest.json 未声明 `offscreen` 权限
- offscreen.html 文件不存在
- Chrome 版本过低（需要 109+）

**解决**:

```json
// manifest.json
{
  "permissions": ["offscreen"],
  "web_accessible_resources": [
    {
      "resources": ["offscreen.html", "offscreen.js"],
      "matches": ["<all_urls>"]
    }
  ]
}
```

### 问题2: 爬取失败率过高

**症状**: 大量书签爬取失败

**原因**:

- 网络问题
- 目标站点限流
- CORS 限制

**解决**:

- 增加重试次数
- 增加批次间延迟
- 检查网络连接

```typescript
// 调整配置
VITE_CRAWLER_BATCH_INTERVAL_MS = 3000 // 增加到3秒
```

### 问题3: 内存占用过高

**症状**: 扩展占用内存超过100MB

**原因**:

- LRU缓存过大
- 任务队列过长
- 内存泄漏

**解决**:

```typescript
// 减小 LRU 缓存大小
const memoryCache = new LRUCache<string, CrawlMetadata>(250, 3 * 60 * 1000)

// 清理旧任务
await crawlTaskScheduler.cleanupCompletedTasks()
```

---

## 🚀 下一步

1. **实施核心组件**
   - `crawl-task-scheduler.ts` ✅
   - `local-crawler-worker.ts` ✅
2. **修改现有代码**
   - 更新 `lightweight-bookmark-enhancer.ts`
   - 移除 Serverless 依赖
3. **UI 集成**
   - 添加刷新按钮
   - 显示进度面板
4. **测试验证**
   - 单元测试
   - 集成测试
   - 压力测试（1000+书签）
5. **性能优化**
   - 监控内存
   - 优化批次大小
   - 调整间隔时间

---

**版本**: v1.0  
**更新时间**: 2025-10-12  
**状态**: ✅ 可用
