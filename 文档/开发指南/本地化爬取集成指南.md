# æœ¬åœ°åŒ–çˆ¬å–ç³»ç»Ÿ - é›†æˆæŒ‡å—

## ğŸ¯ å¿«é€Ÿå¼€å§‹

### 1. é…ç½®ç¯å¢ƒå˜é‡

åœ¨ `.env` æ–‡ä»¶ä¸­è®¾ç½®ï¼š

```bash
# å¼ºåˆ¶ä½¿ç”¨æœ¬åœ°æ¨¡å¼ï¼ˆå…³é”®ï¼ï¼‰
VITE_CRAWLER_MODE=local

# å¹¶å‘æ§åˆ¶
VITE_CRAWLER_CONCURRENCY=2
VITE_CRAWLER_PER_DOMAIN_CONCURRENCY=1

# æ‰¹é‡å¤„ç†
VITE_CRAWLER_BATCH_SIZE=5
VITE_CRAWLER_BATCH_INTERVAL_MS=1500

# å¯ç”¨ç©ºé—²è°ƒåº¦
VITE_CRAWLER_USE_IDLE_SCHEDULING=true
VITE_CRAWLER_IDLE_DELAY_MS=3000

# å°Šé‡ Robots.txt
VITE_CRAWLER_RESPECT_ROBOTS=true
```

### 2. å¯¼å…¥ç»„ä»¶

```typescript
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'
import { warmupOffscreenDocument } from '@/services/local-crawler-worker'
```

### 3. åŸºæœ¬ä½¿ç”¨

```typescript
// é¢„çƒ­ Offscreen Documentï¼ˆå¯é€‰ï¼Œä½†æ¨èï¼‰
await warmupOffscreenDocument()

// è·å–æ‰€æœ‰ä¹¦ç­¾
const bookmarks = await getAllBookmarks()

// è°ƒåº¦çˆ¬å–ä»»åŠ¡
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  priority: 'normal',
  respectRobots: true,

  onProgress: stats => {
    console.log(`è¿›åº¦: ${stats.progress}% (${stats.completed}/${stats.total})`)
  },

  onTaskComplete: task => {
    if (task.result?.success) {
      console.log(`âœ… å®Œæˆ: ${task.url}`)
      // æ›´æ–° UIã€ç¼“å­˜ç­‰
    }
  },

  onComplete: stats => {
    console.log('ğŸ‰ å…¨éƒ¨å®Œæˆ!', stats)
  }
})
```

---

## ğŸ“– è¯¦ç»†ç¤ºä¾‹

### ç¤ºä¾‹1: Management é¡µé¢ - æ‰¹é‡åˆ·æ–°å…ƒæ•°æ®

```typescript
// frontend/src/components/management/MetadataRefreshButton.vue

<template>
  <div class="metadata-refresh">
    <button
      @click="handleRefresh"
      :disabled="isRefreshing"
      class="btn-refresh"
    >
      <span v-if="!isRefreshing">ğŸ”„ åˆ·æ–°æ‰€æœ‰ä¹¦ç­¾å…ƒæ•°æ®</span>
      <span v-else>â³ åˆ·æ–°ä¸­... {{ progress }}%</span>
    </button>

    <div v-if="isRefreshing" class="progress-panel">
      <div class="progress-bar">
        <div class="progress-fill" :style="{ width: progress + '%' }"></div>
      </div>

      <div class="stats">
        <span>æ€»æ•°: {{ stats.total }}</span>
        <span>å®Œæˆ: {{ stats.completed }}</span>
        <span>å¤±è´¥: {{ stats.failed }}</span>
        <span>å¾…å¤„ç†: {{ stats.pending }}</span>
      </div>

      <div class="controls">
        <button @click="handlePause" v-if="!isPaused">â¸ï¸ æš‚åœ</button>
        <button @click="handleResume" v-else>â–¶ï¸ ç»§ç»­</button>
        <button @click="handleCancel">âŒ å–æ¶ˆ</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'
import type { QueueStatistics } from '@/services/crawl-task-scheduler'
import { useBookmarkStore } from '@/stores/bookmark-store'
import { useNotificationStore } from '@/stores/notification-store'

const bookmarkStore = useBookmarkStore()
const notificationStore = useNotificationStore()

const isRefreshing = ref(false)
const isPaused = ref(false)
const stats = ref<QueueStatistics>({
  total: 0,
  completed: 0,
  failed: 0,
  pending: 0,
  running: 0,
  paused: 0,
  progress: 0
})

const progress = computed(() => stats.value.progress)

async function handleRefresh() {
  // 1. è·å–æ‰€æœ‰ä¹¦ç­¾
  const allBookmarks = await bookmarkStore.getAllBookmarks()
  const urlBookmarks = allBookmarks.filter(b => b.url && !b.url.startsWith('chrome://'))

  if (urlBookmarks.length === 0) {
    notificationStore.show({
      message: 'æ²¡æœ‰å¯çˆ¬å–çš„ä¹¦ç­¾',
      type: 'warning'
    })
    return
  }

  // 2. ç¡®è®¤å¯¹è¯æ¡†
  const estimatedTime = Math.ceil((urlBookmarks.length / 2) * 2 / 60) // ç²—ç•¥ä¼°è®¡
  const confirmed = confirm(
    `å°†åœ¨åå°çˆ¬å– ${urlBookmarks.length} ä¸ªä¹¦ç­¾çš„å…ƒæ•°æ®\n` +
    `é¢„è®¡éœ€è¦çº¦ ${estimatedTime} åˆ†é’Ÿ\n` +
    `æ˜¯å¦ç»§ç»­ï¼Ÿ`
  )

  if (!confirmed) return

  // 3. å¼€å§‹åˆ·æ–°
  isRefreshing.value = true
  isPaused.value = false

  try {
    await crawlTaskScheduler.scheduleBookmarksCrawl(urlBookmarks, {
      priority: 'normal',
      respectRobots: true,

      onProgress: (newStats) => {
        stats.value = newStats
      },

      onTaskComplete: async (task) => {
        if (task.result?.success && task.result.metadata) {
          // æ›´æ–°ä¹¦ç­¾å…ƒæ•°æ®
          await bookmarkStore.updateBookmarkMetadata(task.bookmarkId, {
            title: task.result.metadata.title || task.bookmarkTitle,
            description: task.result.metadata.description,
            keywords: task.result.metadata.keywords,
            // ... å…¶ä»–å­—æ®µ
          })
        }
      },

      onComplete: (finalStats) => {
        notificationStore.show({
          message: `å…ƒæ•°æ®åˆ·æ–°å®Œæˆï¼æˆåŠŸ: ${finalStats.completed}, å¤±è´¥: ${finalStats.failed}`,
          type: 'success'
        })

        isRefreshing.value = false
      },

      onError: (error) => {
        notificationStore.show({
          message: `åˆ·æ–°å‡ºé”™: ${error.message}`,
          type: 'error'
        })

        isRefreshing.value = false
      }
    })
  } catch (error) {
    console.error('åˆ·æ–°å…ƒæ•°æ®å¤±è´¥:', error)
    notificationStore.show({
      message: 'å¯åŠ¨åˆ·æ–°å¤±è´¥',
      type: 'error'
    })

    isRefreshing.value = false
  }
}

function handlePause() {
  crawlTaskScheduler.pause()
  isPaused.value = true
}

function handleResume() {
  crawlTaskScheduler.resume()
  isPaused.value = false
}

async function handleCancel() {
  const confirmed = confirm('ç¡®å®šè¦å–æ¶ˆåˆ·æ–°å—ï¼Ÿ')
  if (confirmed) {
    await crawlTaskScheduler.cancelAll()
    isRefreshing.value = false
    isPaused.value = false
  }
}
</script>

<style scoped>
.metadata-refresh {
  padding: 1rem;
}

.btn-refresh {
  padding: 0.5rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background: #4285f4;
  color: white;
  transition: background 0.2s;
}

.btn-refresh:hover:not(:disabled) {
  background: #357ae8;
}

.btn-refresh:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.progress-panel {
  margin-top: 1rem;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.progress-bar {
  width: 100%;
  height: 8px;
  background: #eee;
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #4285f4;
  transition: width 0.3s;
}

.stats {
  margin-top: 1rem;
  display: flex;
  gap: 1rem;
  font-size: 0.9rem;
}

.controls {
  margin-top: 1rem;
  display: flex;
  gap: 0.5rem;
}

.controls button {
  padding: 0.3rem 0.8rem;
  font-size: 0.9rem;
  cursor: pointer;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

.controls button:hover {
  background: #f5f5f5;
}
</style>
```

---

### ç¤ºä¾‹2: æ–°å¢ä¹¦ç­¾æ—¶è‡ªåŠ¨çˆ¬å–

```typescript
// frontend/src/services/bookmark-auto-crawl.ts

import { crawlTaskScheduler } from './crawl-task-scheduler'
import { lightweightBookmarkEnhancer } from './lightweight-bookmark-enhancer'
import { logger } from '@/infrastructure/logging/logger'

/**
 * ç›‘å¬ä¹¦ç­¾åˆ›å»ºäº‹ä»¶ï¼Œè‡ªåŠ¨çˆ¬å–å…ƒæ•°æ®
 */
export function setupAutoBookmarkCrawl() {
  chrome.bookmarks.onCreated.addListener(async (id, bookmark) => {
    // åªå¤„ç† URL ä¹¦ç­¾
    if (!bookmark.url || bookmark.url.startsWith('chrome://')) {
      return
    }

    logger.info('AutoCrawl', `ğŸ“Œ æ–°ä¹¦ç­¾åˆ›å»º: ${bookmark.url}`)

    try {
      // æ–¹å¼1: ç«‹å³çˆ¬å–ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰
      await crawlTaskScheduler.scheduleBookmarksCrawl([bookmark], {
        priority: 'high',
        onTaskComplete: async task => {
          if (task.result?.success && task.result.metadata) {
            // ä¿å­˜å…ƒæ•°æ®åˆ°ç¼“å­˜
            await lightweightBookmarkEnhancer.saveMetadata({
              bookmarkId: id,
              url: bookmark.url!,
              title: task.result.metadata.title || bookmark.title || '',
              ...task.result.metadata
            })

            logger.info('AutoCrawl', `âœ… æ–°ä¹¦ç­¾å…ƒæ•°æ®å·²è·å–: ${bookmark.url}`)
          }
        }
      })
    } catch (error) {
      logger.error('AutoCrawl', 'æ–°ä¹¦ç­¾çˆ¬å–å¤±è´¥', error)
    }
  })

  logger.info('AutoCrawl', 'âœ… è‡ªåŠ¨çˆ¬å–å·²å¯ç”¨')
}
```

---

### ç¤ºä¾‹3: Background Script åˆå§‹åŒ–

```typescript
// frontend/background.js

import { setupAutoBookmarkCrawl } from './src/services/bookmark-auto-crawl'
import { warmupOffscreenDocument } from './src/services/local-crawler-worker'
import { crawlTaskScheduler } from './src/services/crawl-task-scheduler'

// æ‰©å±•å®‰è£…/æ›´æ–°æ—¶
chrome.runtime.onInstalled.addListener(async details => {
  if (details.reason === 'install') {
    console.log('ğŸ‰ AcuityBookmarks å·²å®‰è£…')

    // é¢„çƒ­ Offscreen Document
    await warmupOffscreenDocument()

    // å¯åŠ¨è‡ªåŠ¨çˆ¬å–
    setupAutoBookmarkCrawl()

    // æ˜¾ç¤ºæ¬¢è¿é¡µé¢
    chrome.tabs.create({ url: 'management.html' })
  }

  if (details.reason === 'update') {
    console.log('ğŸ”„ AcuityBookmarks å·²æ›´æ–°')

    // é¢„çƒ­ Offscreen Document
    await warmupOffscreenDocument()
  }
})

// æ‰©å±•å¯åŠ¨æ—¶
chrome.runtime.onStartup.addListener(async () => {
  console.log('ğŸš€ AcuityBookmarks å·²å¯åŠ¨')

  // é¢„çƒ­ Offscreen Document
  await warmupOffscreenDocument()

  // å¯åŠ¨è‡ªåŠ¨çˆ¬å–
  setupAutoBookmarkCrawl()

  // æ¢å¤ä¸­æ–­çš„çˆ¬å–ä»»åŠ¡
  const stats = crawlTaskScheduler.getStatistics()
  if (stats.pending > 0) {
    console.log(`ğŸ“‚ æ¢å¤ ${stats.pending} ä¸ªå¾…å¤„ç†ä»»åŠ¡`)
    crawlTaskScheduler.resume()
  }
})
```

---

### ç¤ºä¾‹4: å®šæœŸåå°åˆ·æ–°

```typescript
// frontend/src/services/background-refresh.ts

import { crawlTaskScheduler } from './crawl-task-scheduler'
import { indexedDBManager } from '@/infrastructure/indexeddb/manager'
import { logger } from '@/infrastructure/logging/logger'

/**
 * è®¾ç½®å®šæœŸåå°åˆ·æ–°
 */
export function setupBackgroundRefresh() {
  // æ¯å¤©å‡Œæ™¨2ç‚¹åˆ·æ–°ä¸€æ¬¡è¿‡æœŸçš„ä¹¦ç­¾
  chrome.alarms.create('refresh-expired-bookmarks', {
    when: getNextMidnight(),
    periodInMinutes: 24 * 60 // æ¯24å°æ—¶
  })

  chrome.alarms.onAlarm.addListener(async alarm => {
    if (alarm.name === 'refresh-expired-bookmarks') {
      await refreshExpiredBookmarks()
    }
  })

  logger.info('BackgroundRefresh', 'âœ… å®šæœŸåˆ·æ–°å·²è®¾ç½®')
}

/**
 * åˆ·æ–°è¿‡æœŸçš„ä¹¦ç­¾å…ƒæ•°æ®
 */
async function refreshExpiredBookmarks() {
  try {
    logger.info('BackgroundRefresh', 'ğŸ”„ å¼€å§‹åˆ·æ–°è¿‡æœŸä¹¦ç­¾')

    // 1. è·å–æ‰€æœ‰è¿‡æœŸçš„ä¹¦ç­¾
    const expiredBookmarks = await indexedDBManager.getExpiredBookmarks()

    if (expiredBookmarks.length === 0) {
      logger.info('BackgroundRefresh', 'âœ… æ²¡æœ‰è¿‡æœŸä¹¦ç­¾éœ€è¦åˆ·æ–°')
      return
    }

    logger.info(
      'BackgroundRefresh',
      `ğŸ“‹ å‘ç° ${expiredBookmarks.length} ä¸ªè¿‡æœŸä¹¦ç­¾`
    )

    // 2. è°ƒåº¦åˆ·æ–°ä»»åŠ¡ï¼ˆä½ä¼˜å…ˆçº§ï¼Œä¸å½±å“ç”¨æˆ·ï¼‰
    await crawlTaskScheduler.scheduleBookmarksCrawl(expiredBookmarks, {
      priority: 'low',
      respectRobots: true,

      onComplete: stats => {
        logger.info('BackgroundRefresh', 'âœ… åå°åˆ·æ–°å®Œæˆ', stats)

        // å‘é€é€šçŸ¥ï¼ˆå¯é€‰ï¼‰
        if (stats.completed > 0) {
          chrome.notifications.create({
            type: 'basic',
            iconUrl: 'images/icon128.png',
            title: 'AcuityBookmarks',
            message: `å·²åˆ·æ–° ${stats.completed} ä¸ªä¹¦ç­¾çš„å…ƒæ•°æ®`
          })
        }
      }
    })
  } catch (error) {
    logger.error('BackgroundRefresh', 'åå°åˆ·æ–°å¤±è´¥', error)
  }
}

/**
 * è·å–ä¸‹æ¬¡å‡Œæ™¨2ç‚¹çš„æ—¶é—´æˆ³
 */
function getNextMidnight(): number {
  const now = new Date()
  const next = new Date(
    now.getFullYear(),
    now.getMonth(),
    now.getDate() + 1,
    2, // å‡Œæ™¨2ç‚¹
    0,
    0
  )
  return next.getTime()
}
```

---

## ğŸ”§ ä¿®æ”¹ç°æœ‰ä»£ç 

### 1. ä¿®æ”¹ `lightweight-bookmark-enhancer.ts`

å°† Serverless çˆ¬å–æ”¹ä¸ºæœ¬åœ°çˆ¬å–ï¼š

```typescript
// æ‰¾åˆ° crawlAndCache æ–¹æ³•ï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š

private async crawlAndCache(
  bookmark: chrome.bookmarks.BookmarkTreeNode
): Promise<LightweightBookmarkMetadata> {
  const startTime = Date.now()
  logger.info('LightweightEnhancer', `ğŸš€ å¼€å§‹çˆ¬å–: ${bookmark.url}`)

  try {
    if (!bookmark.url) {
      throw new Error(`ä¹¦ç­¾URLä¸ºç©º: ${bookmark.id}`)
    }

    // åå°ç©ºé—²è°ƒåº¦
    await this.deferForIdleIfNeeded()

    // âœ… ä½¿ç”¨æ–°çš„æœ¬åœ°çˆ¬è™«ï¼ˆç§»é™¤ Serverless è°ƒç”¨ï¼‰
    const result = await crawlBookmarkLocally(bookmark.url, {
      respectRobots: true,
      timeout: 10000
    })

    if (!result.success || !result.metadata) {
      throw new Error(result.error || 'çˆ¬å–å¤±è´¥')
    }

    // æ„å»ºå…ƒæ•°æ®å¯¹è±¡
    const metadata: LightweightBookmarkMetadata = {
      // Chrome å­—æ®µ
      id: bookmark.id,
      url: bookmark.url,
      title: bookmark.title || '',
      dateAdded: bookmark.dateAdded,
      dateLastUsed: bookmark.dateLastUsed,
      parentId: bookmark.parentId,

      // çˆ¬å–å­—æ®µ
      extractedTitle: result.metadata.title,
      description: result.metadata.description,
      keywords: result.metadata.keywords,
      ogTitle: result.metadata.ogTitle,
      ogDescription: result.metadata.ogDescription,
      ogImage: result.metadata.ogImage,
      ogSiteName: result.metadata.ogSiteName,

      // ç¼“å­˜å­—æ®µ
      lastCrawled: Date.now(),
      crawlSuccess: true,
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,
      crawlCount: 1,
      finalUrl: result.url,
      lastModified: new Date().toISOString(),

      // çŠ¶æ€å­—æ®µ
      crawlStatus: {
        lastCrawled: Date.now(),
        status: 'success',
        crawlDuration: result.duration,
        version: 2,
        source: 'local-crawler',
        finalUrl: result.url,
        httpStatus: result.httpStatus
      }
    }

    // ä¿å­˜åˆ°ç¼“å­˜
    await this.saveToCacheInternal(metadata)
    await this.saveToUnifiedIndexedDB(metadata)
    await this.incrementDailyCounter()

    logger.info(
      'LightweightEnhancer',
      `âœ… çˆ¬å–æˆåŠŸ: ${bookmark.url} (${Date.now() - startTime}ms)`
    )

    return metadata
  } catch (error) {
    logger.error('LightweightEnhancer', `âŒ çˆ¬å–å¤±è´¥: ${bookmark.url}`, error)
    // ... é”™è¯¯å¤„ç†
  }
}
```

### 2. ç§»é™¤ Serverless ä¾èµ–

```typescript
// ç§»é™¤è¿™äº›å¯¼å…¥ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
// import { serverlessCrawlerClient } from './serverless-crawler-client'
// import { API_CONFIG } from '@/config/constants'

// æ·»åŠ æ–°çš„å¯¼å…¥
import { crawlBookmarkLocally } from './local-crawler-worker'
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. é¢„çƒ­ Offscreen Document

åœ¨åº”ç”¨å¯åŠ¨æ—¶é¢„çƒ­ï¼Œé¿å…é¦–æ¬¡çˆ¬å–å»¶è¿Ÿï¼š

```typescript
// åœ¨ main.ts æˆ– background.js ä¸­
import { warmupOffscreenDocument } from '@/services/local-crawler-worker'

// åº”ç”¨åˆå§‹åŒ–æ—¶
warmupOffscreenDocument()
```

### 2. ä½¿ç”¨åˆé€‚çš„ä¼˜å…ˆçº§

```typescript
// ç”¨æˆ·æ‰‹åŠ¨è§¦å‘ â†’ é«˜ä¼˜å…ˆçº§
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  priority: 'high' // æˆ– 'urgent'
})

// æ–°å¢ä¹¦ç­¾è‡ªåŠ¨çˆ¬å– â†’ æ™®é€šä¼˜å…ˆçº§
await crawlTaskScheduler.scheduleBookmarksCrawl([bookmark], {
  priority: 'normal'
})

// åå°å®šæœŸåˆ·æ–° â†’ ä½ä¼˜å…ˆçº§
await crawlTaskScheduler.scheduleBookmarksCrawl(expiredBookmarks, {
  priority: 'low'
})
```

### 3. æ¸è¿›å¼æ•°æ®å‘ˆç°

```typescript
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  onTaskComplete: async task => {
    if (task.result?.success) {
      // ç«‹å³æ›´æ–° UIï¼ˆä¸ç­‰å¾…å…¨éƒ¨å®Œæˆï¼‰
      await updateBookmarkInUI(task.bookmarkId, task.result.metadata)
    }
  }
})
```

### 4. é”™è¯¯å¤„ç†

```typescript
await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
  onTaskComplete: task => {
    if (task.status === 'failed') {
      // è®°å½•å¤±è´¥åŸå› 
      logger.warn('Crawl', `å¤±è´¥: ${task.url}`, task.error)

      // å¯ä»¥é€‰æ‹©æ€§åœ°é‡æ–°è°ƒåº¦
      if (task.error?.includes('timeout')) {
        // ç¨åé‡è¯•è¶…æ—¶ä»»åŠ¡
      }
    }
  }
})
```

### 5. æ€§èƒ½ç›‘æ§

```typescript
import { getCrawlerStats } from '@/services/local-crawler-worker'

// å®šæœŸæ£€æŸ¥
setInterval(() => {
  const stats = getCrawlerStats()
  const queueStats = crawlTaskScheduler.getStatistics()

  console.log('çˆ¬è™«çŠ¶æ€:', {
    ç¼“å­˜åŸŸåæ•°: stats.domainsCached,
    Robotsç¼“å­˜æ•°: stats.robotsCached,
    é˜Ÿåˆ—è¿›åº¦: `${queueStats.progress}%`,
    è¿è¡Œä¸­ä»»åŠ¡: queueStats.running
  })
}, 60000) // æ¯åˆ†é’Ÿ
```

---

## ğŸ§ª æµ‹è¯•

### å•å…ƒæµ‹è¯•

```typescript
// __tests__/local-crawler-worker.test.ts

import { describe, it, expect, vi } from 'vitest'
import { crawlBookmarkLocally } from '@/services/local-crawler-worker'

describe('LocalCrawlerWorker', () => {
  it('should crawl a valid URL successfully', async () => {
    const result = await crawlBookmarkLocally('https://example.com')

    expect(result.success).toBe(true)
    expect(result.metadata).toBeDefined()
    expect(result.metadata?.title).toBeTruthy()
  })

  it('should respect robots.txt', async () => {
    const result = await crawlBookmarkLocally('https://blocked-site.com', {
      respectRobots: true
    })

    if (!result.success && result.errorType === 'robots') {
      expect(result.robotsAllowed).toBe(false)
    }
  })

  it('should handle timeout', async () => {
    const result = await crawlBookmarkLocally('https://slow-site.com', {
      timeout: 100 // å¾ˆçŸ­çš„è¶…æ—¶
    })

    if (!result.success) {
      expect(result.errorType).toBe('timeout')
    }
  }, 10000)
})
```

### é›†æˆæµ‹è¯•

```typescript
// __tests__/crawl-task-scheduler.test.ts

import { describe, it, expect } from 'vitest'
import { crawlTaskScheduler } from '@/services/crawl-task-scheduler'

describe('CrawlTaskScheduler', () => {
  it('should schedule and execute bookmark crawl', async () => {
    const testBookmarks = [
      {
        id: '1',
        title: 'Test 1',
        url: 'https://example.com',
        dateAdded: Date.now()
      },
      {
        id: '2',
        title: 'Test 2',
        url: 'https://example.org',
        dateAdded: Date.now()
      }
    ]

    let completedCount = 0

    await crawlTaskScheduler.scheduleBookmarksCrawl(testBookmarks, {
      priority: 'high',
      onTaskComplete: () => {
        completedCount++
      }
    })

    // ç­‰å¾…å®Œæˆ
    await new Promise(resolve => setTimeout(resolve, 10000))

    const stats = crawlTaskScheduler.getStatistics()
    expect(stats.completed + stats.failed).toBe(testBookmarks.length)
  }, 30000)
})
```

---

## ğŸ“Š æ€§èƒ½é¢„æœŸ

### 1000æ¡ä¹¦ç­¾çš„é¢„æœŸè¡¨ç°

| æŒ‡æ ‡             | å€¼       |
| ---------------- | -------- |
| URLå»é‡å        | ~700æ¡   |
| ç¼“å­˜å‘½ä¸­ï¼ˆ30å¤©ï¼‰ | ~80%     |
| å®é™…éœ€çˆ¬å–       | ~140æ¡   |
| å¹³å‡å•æ¬¡è€—æ—¶     | 2ç§’      |
| å¹¶å‘æ•°           | 2        |
| æ€»è€—æ—¶           | ~2.5åˆ†é’Ÿ |
| å†…å­˜å ç”¨         | <50MB    |
| CPUå ç”¨          | <5%      |

### ç”¨æˆ·ä½“éªŒ

- âœ… **é›¶é˜»å¡**ï¼šåå°é™é»˜æ‰§è¡Œ
- âœ… **å®æ—¶åé¦ˆ**ï¼šæ¸è¿›å¼æ•°æ®å‘ˆç°
- âœ… **å¯æ§åˆ¶**ï¼šæš‚åœ/ç»§ç»­/å–æ¶ˆ
- âœ… **å¯æ¢å¤**ï¼šæ–­ç‚¹ç»­çˆ¬
- âœ… **éšç§å®‰å…¨**ï¼š100%æœ¬åœ°æ‰§è¡Œ

---

## ğŸ” æ•…éšœæ’æŸ¥

### é—®é¢˜1: Offscreen Document åˆ›å»ºå¤±è´¥

**ç—‡çŠ¶**: æ§åˆ¶å°æ˜¾ç¤º "æ— æ³•åˆ›å»º Offscreen Document"

**åŸå› **:

- manifest.json æœªå£°æ˜ `offscreen` æƒé™
- offscreen.html æ–‡ä»¶ä¸å­˜åœ¨
- Chrome ç‰ˆæœ¬è¿‡ä½ï¼ˆéœ€è¦ 109+ï¼‰

**è§£å†³**:

```json
// manifest.json
{
  "permissions": ["offscreen"],
  "web_accessible_resources": [
    {
      "resources": ["offscreen.html", "offscreen.js"],
      "matches": ["<all_urls>"]
    }
  ]
}
```

### é—®é¢˜2: çˆ¬å–å¤±è´¥ç‡è¿‡é«˜

**ç—‡çŠ¶**: å¤§é‡ä¹¦ç­¾çˆ¬å–å¤±è´¥

**åŸå› **:

- ç½‘ç»œé—®é¢˜
- ç›®æ ‡ç«™ç‚¹é™æµ
- CORS é™åˆ¶

**è§£å†³**:

- å¢åŠ é‡è¯•æ¬¡æ•°
- å¢åŠ æ‰¹æ¬¡é—´å»¶è¿Ÿ
- æ£€æŸ¥ç½‘ç»œè¿æ¥

```typescript
// è°ƒæ•´é…ç½®
VITE_CRAWLER_BATCH_INTERVAL_MS = 3000 // å¢åŠ åˆ°3ç§’
```

### é—®é¢˜3: å†…å­˜å ç”¨è¿‡é«˜

**ç—‡çŠ¶**: æ‰©å±•å ç”¨å†…å­˜è¶…è¿‡100MB

**åŸå› **:

- LRUç¼“å­˜è¿‡å¤§
- ä»»åŠ¡é˜Ÿåˆ—è¿‡é•¿
- å†…å­˜æ³„æ¼

**è§£å†³**:

```typescript
// å‡å° LRU ç¼“å­˜å¤§å°
const memoryCache = new LRUCache<string, CrawlMetadata>(250, 3 * 60 * 1000)

// æ¸…ç†æ—§ä»»åŠ¡
await crawlTaskScheduler.cleanupCompletedTasks()
```

---

## ğŸš€ ä¸‹ä¸€æ­¥

1. **å®æ–½æ ¸å¿ƒç»„ä»¶**
   - `crawl-task-scheduler.ts` âœ…
   - `local-crawler-worker.ts` âœ…
2. **ä¿®æ”¹ç°æœ‰ä»£ç **
   - æ›´æ–° `lightweight-bookmark-enhancer.ts`
   - ç§»é™¤ Serverless ä¾èµ–
3. **UI é›†æˆ**
   - æ·»åŠ åˆ·æ–°æŒ‰é’®
   - æ˜¾ç¤ºè¿›åº¦é¢æ¿
4. **æµ‹è¯•éªŒè¯**
   - å•å…ƒæµ‹è¯•
   - é›†æˆæµ‹è¯•
   - å‹åŠ›æµ‹è¯•ï¼ˆ1000+ä¹¦ç­¾ï¼‰
5. **æ€§èƒ½ä¼˜åŒ–**
   - ç›‘æ§å†…å­˜
   - ä¼˜åŒ–æ‰¹æ¬¡å¤§å°
   - è°ƒæ•´é—´éš”æ—¶é—´

---

**ç‰ˆæœ¬**: v1.0  
**æ›´æ–°æ—¶é—´**: 2025-10-12  
**çŠ¶æ€**: âœ… å¯ç”¨
