# 本地化爬取 - 5分钟快速测试 ⚡

## 🎯 目标

**用最快的方式验证爬取功能是否正常工作！**

---

## 📋 前置条件

1. ✅ 已运行 `npm run build`
2. ✅ 已在 Chrome 中加载扩展（`chrome://extensions`）
3. ✅ Chrome 中有一些书签

---

## 🚀 5分钟测试流程

### 步骤 1: 打开控制台（30秒）

1. 点击 Chrome 扩展图标
2. 点击 "管理书签" 或 "Management"
3. 按 `F12` 打开开发者工具
4. 切换到 "Console" 标签

### 步骤 2: 导入测试工具（30秒）

在控制台粘贴并执行：

```javascript
// 快速导入爬取工具
const crawlerModule = await import('./assets/app-services.CvlJmFwV.js')
const { crawlSingleBookmark, getCrawlStatistics, getBookmarkMetadata } =
  crawlerModule

// 快速获取一个测试书签
const testBookmarks = await chrome.bookmarks.search({})
const testBookmark = testBookmarks.find(b => b.url)

console.log('✅ 测试工具已加载')
console.log('📚 测试书签:', testBookmark?.title, testBookmark?.url)
```

**⚠️ 注意**：如果在 Service Worker 控制台测试，不要使用 `window` 对象：

```javascript
// ❌ 错误（Service Worker 没有 window）
const crawler = window.bookmarkCrawler

// ✅ 正确（使用 self 或 globalThis）
const crawler = self.bookmarkCrawler
// 或
const crawler = globalThis.bookmarkCrawler
```

### 步骤 3: 测试单个爬取（1分钟）

```javascript
// 爬取测试书签
console.log('🚀 开始爬取...')
await crawlSingleBookmark(testBookmark, { priority: 'high' })

console.log('✅ 爬取完成！')
```

**预期看到**：

```
🚀 开始爬取...
[LocalCrawler] 🔍 开始爬取书签: GitHub
[LocalCrawler] ✅ 爬取成功
✅ 爬取完成！
```

### 步骤 4: 验证结果（1分钟）

```javascript
// 获取爬取的元数据
const metadata = await getBookmarkMetadata(testBookmark.id)

console.log('📊 爬取结果:')
console.log('  标题:', metadata?.pageTitle)
console.log('  描述:', metadata?.description)
console.log('  关键词:', metadata?.keywords)
console.log('  状态:', metadata?.status)
console.log('  HTTP状态:', metadata?.httpStatus)
```

**预期看到**：

```
📊 爬取结果:
  标题: GitHub: Let's build from here
  描述: GitHub is where over 100 million developers...
  关键词: github, code, repository, git
  状态: success
  HTTP状态: 200
```

### 步骤 5: 查看统计（30秒）

```javascript
// 查看整体统计
const stats = await getCrawlStatistics()

console.log('📈 统计信息:')
console.log('  总计:', stats.total)
console.log('  已爬取:', stats.withMetadata)
console.log('  失败:', stats.failed)
console.log(
  '  成功率:',
  (((stats.withMetadata - stats.failed) / stats.total) * 100).toFixed(1) + '%'
)
```

**预期看到**：

```
📈 统计信息:
  总计: 1
  已爬取: 1
  失败: 0
  成功率: 100.0%
```

---

## ✅ 成功标志

如果你看到以下内容，说明爬取功能**完全正常**：

- ✅ 无错误信息
- ✅ `metadata.status` = "success"
- ✅ `metadata.pageTitle` 有内容
- ✅ `metadata.httpStatus` = 200
- ✅ 统计信息正确

---

## 🎯 进阶测试（可选）

### 批量测试 10 个书签

```javascript
// 获取 10 个书签
const batch = testBookmarks.filter(b => b.url).slice(0, 10)

console.log(`📚 准备测试 ${batch.length} 个书签`)

// 导入批量爬取
const { crawlMultipleBookmarks } = crawlerModule

// 批量爬取
await crawlMultipleBookmarks(batch, {
  priority: 'normal',
  onProgress: (done, total) => {
    console.log(`📊 进度: ${done}/${total}`)
  },
  onComplete: results => {
    const success = results.filter(r => r.success).length
    console.log(`✅ 完成: ${success}/${results.length}`)
  }
})

// 再次查看统计
const newStats = await getCrawlStatistics()
console.log('📈 更新后统计:', newStats)
```

---

## 🐛 遇到问题？

### 问题 1: `Cannot find module` 错误

**原因**: 资源文件名可能不同

**解决**:

```javascript
// 方式 A: 使用相对路径
const crawlerModule = await import('../services/local-bookmark-crawler.js')

// 方式 B: 在 Service Worker 中测试
// chrome://extensions → Service Worker → Console
```

### 问题 2: 爬取没有反应

**检查 Offscreen Document**:

```javascript
const hasOffscreen = await chrome.offscreen.hasDocument()
console.log('Offscreen 存在:', hasOffscreen)

// 如果不存在，手动创建
if (!hasOffscreen) {
  const { createOffscreenDocument } = await import('./page-fetcher.js')
  await createOffscreenDocument()
  console.log('✅ Offscreen Document 已创建')
}
```

### 问题 3: 数据没有保存

**手动检查 IndexedDB**:

```javascript
const { indexedDBManager } = await import(
  './infrastructure/indexeddb/manager.js'
)
await indexedDBManager.initialize()

const allMeta = await indexedDBManager.getAllCrawlMetadata()
console.log('📊 已保存的元数据数量:', allMeta.length)
console.log('📄 示例数据:', allMeta[0])
```

---

## 📝 快捷测试命令

复制粘贴整段代码，一次性完成所有测试：

```javascript
;(async function quickTest() {
  console.log('🧪 开始快速测试...\n')

  try {
    // 1. 导入模块
    console.log('1️⃣ 导入模块...')
    const { crawlSingleBookmark, getCrawlStatistics, getBookmarkMetadata } =
      await import('./assets/app-services.CvlJmFwV.js')

    // 2. 获取测试书签
    console.log('2️⃣ 获取测试书签...')
    const bookmarks = await chrome.bookmarks.search({})
    const testBookmark = bookmarks.find(b => b.url)

    if (!testBookmark) {
      console.error('❌ 没有找到可测试的书签')
      return
    }

    console.log(`   📚 ${testBookmark.title} - ${testBookmark.url}`)

    // 3. 爬取
    console.log('\n3️⃣ 开始爬取...')
    const startTime = Date.now()
    await crawlSingleBookmark(testBookmark, { priority: 'high' })
    const duration = Date.now() - startTime
    console.log(`   ⏱️ 耗时: ${duration}ms`)

    // 4. 验证结果
    console.log('\n4️⃣ 验证结果...')
    const metadata = await getBookmarkMetadata(testBookmark.id)

    if (metadata) {
      console.log('   ✅ 标题:', metadata.pageTitle)
      console.log('   ✅ 描述:', metadata.description?.substring(0, 50) + '...')
      console.log('   ✅ 状态:', metadata.status)
      console.log('   ✅ HTTP:', metadata.httpStatus)
    } else {
      console.error('   ❌ 未找到元数据')
    }

    // 5. 统计
    console.log('\n5️⃣ 统计信息...')
    const stats = await getCrawlStatistics()
    console.log('   📊 总计:', stats.total)
    console.log('   📊 成功:', stats.withMetadata)
    console.log('   📊 失败:', stats.failed)

    // 结论
    console.log('\n' + '='.repeat(50))
    if (metadata && metadata.status === 'success') {
      console.log('🎉 测试通过！爬取功能正常工作！')
    } else {
      console.log('⚠️ 测试未完全通过，请检查错误信息')
    }
    console.log('='.repeat(50))
  } catch (error) {
    console.error('❌ 测试失败:', error)
    console.error('错误详情:', error.stack)
  }
})()
```

---

## ⏱️ 预计时间

| 步骤       | 时间        | 累计    |
| ---------- | ----------- | ------- |
| 打开控制台 | 30秒        | 30秒    |
| 导入工具   | 30秒        | 1分钟   |
| 单个爬取   | 1分钟       | 2分钟   |
| 验证结果   | 1分钟       | 3分钟   |
| 查看统计   | 30秒        | 3.5分钟 |
| **总计**   | **3.5分钟** |         |

---

## 🎓 下一步

测试通过后，你可以：

1. 📖 阅读 [完整测试指南](./本地化爬取-测试指南.md)
2. 🔧 配置 [自动爬取触发](./本地化爬取-集成指南.md)
3. 🚀 进行 [大批量性能测试](./本地化爬取-测试指南.md#场景-5-性能测试大批量)

---

**祝测试顺利！** 🎉
