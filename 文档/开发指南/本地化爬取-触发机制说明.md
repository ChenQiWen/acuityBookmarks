# 本地化爬取 - 触发机制说明

## 📋 触发时机概述

目前爬取功能**不会自动触发**，需要手动调用。以下是各种触发方式的说明。

---

## 🎯 当前触发方式

### 1. 手动触发（开发/测试）✅

**适用场景**: 测试、调试、手动刷新元数据

**触发方法**:

#### A. 浏览器控制台

```javascript
// 在 Management 页面或 Service Worker 控制台
const { crawlSingleBookmark, crawlMultipleBookmarks } = await import(
  './services/local-bookmark-crawler'
)

// 爬取单个书签
const bookmark = (await chrome.bookmarks.search({}))[0]
await crawlSingleBookmark(bookmark)

// 批量爬取
const bookmarks = await chrome.bookmarks.search({})
await crawlMultipleBookmarks(bookmarks.filter(b => b.url))
```

#### B. 使用全局快捷工具

```javascript
// 如果已加载 bookmark-crawler-trigger.ts
window.bookmarkCrawler.testUrl('https://github.com')
window.bookmarkCrawler.crawlUnprocessed(100)
window.bookmarkCrawler.getStatus()
```

---

### 2. 智能推荐触发 ⚡

**当前状态**: ✅ 已集成（间接触发）

**触发位置**: `SmartBookmarkRecommendations.vue` 和 `smart-recommendation-engine.ts`

**触发时机**:

- 用户打开智能推荐功能时
- 系统进行书签分析时

**代码位置**:

```typescript
// frontend/src/services/smart-recommendation-engine.ts
await lightweightBookmarkEnhancer.enhanceBookmark(bookmark)
```

**注意**: 这使用的是旧的 API，内部会委托给新的本地爬取。

---

### 3. 增量爬取（新增）✅

**功能**: 只爬取未处理或过期的书签

**使用方法**:

```typescript
import { crawlUnprocessedBookmarks } from './services/bookmark-crawler-trigger'

// 爬取前 100 个未处理的书签
await crawlUnprocessedBookmarks(100)
```

**判断逻辑**:

```typescript
// 需要爬取的条件：
1. bookmark.url 存在（不是文件夹）
2. bookmark.hasMetadata === false（从未爬取）
   OR
3. (Date.now() - bookmark.metadataUpdatedAt) > 30天（数据过期）
```

---

## 🚀 计划中的自动触发方式

### 1. 书签新增时自动爬取 🔮

**状态**: 代码已实现，待集成

**启用方法**:

```typescript
// 在 background.js 或 Service Worker 中添加
import { startAutocrawlOnBookmarkAdd } from './services/bookmark-crawler-trigger'

// 启动监听
startAutocrawlOnBookmarkAdd()
```

**工作原理**:

```typescript
chrome.bookmarks.onCreated.addListener((id, bookmark) => {
  if (bookmark.url) {
    // 延迟1秒后爬取，避免频繁操作
    setTimeout(() => crawlSingleBookmark(bookmark), 1000)
  }
})
```

---

### 2. 定时批量爬取 🔮

**状态**: 代码已实现，待集成

**启用方法**:

```typescript
// 在 background.js 中添加
import { startPeriodicCrawl } from './services/bookmark-crawler-trigger'

// 每24小时爬取一次
startPeriodicCrawl(24)
```

**工作原理**:

```typescript
// 使用 Chrome Alarms API
chrome.alarms.create('bookmark-periodic-crawl', {
  delayInMinutes: 1, // 启动后1分钟开始
  periodInMinutes: 24 * 60 // 每24小时重复
})

chrome.alarms.onAlarm.addListener(alarm => {
  if (alarm.name === 'bookmark-periodic-crawl') {
    crawlUnprocessedBookmarks(100) // 每次爬取100个
  }
})
```

---

### 3. Management 页面打开时自动爬取 🔮

**状态**: 待实现

**实现方式**:

在 `Management.vue` 的 `onMounted` 钩子中：

```typescript
// frontend/src/views/Management.vue
import { crawlUnprocessedBookmarks } from '@/services/bookmark-crawler-trigger'

onMounted(async () => {
  // 检查上次爬取时间
  const lastCrawl = localStorage.getItem('lastAutoCrawl')
  const now = Date.now()

  // 如果超过1小时，自动爬取
  if (!lastCrawl || now - parseInt(lastCrawl) > 60 * 60 * 1000) {
    // 后台静默爬取 50 个
    crawlUnprocessedBookmarks(50).catch(console.error)
    localStorage.setItem('lastAutoCrawl', now.toString())
  }
})
```

---

### 4. 空闲时自动爬取 🔮

**状态**: 待实现

**实现方式**:

```typescript
// 在 Service Worker 中
chrome.idle.onStateChanged.addListener(state => {
  if (state === 'idle') {
    // 用户空闲时，爬取未处理的书签
    crawlUnprocessedBookmarks(100).catch(console.error)
  }
})
```

---

## 🎯 推荐的触发策略

### 阶段 1: MVP（当前）

✅ **手动触发 + 智能推荐触发**

- 优点：简单、可控、不影响用户
- 缺点：覆盖率低

### 阶段 2: 自动化（推荐）

🔮 **书签新增触发 + 定时爬取**

```typescript
// 在 background.js 中集成
import {
  startAutocrawlOnBookmarkAdd,
  startPeriodicCrawl
} from './services/bookmark-crawler-trigger'

// 1. 监听新书签
startAutocrawlOnBookmarkAdd()

// 2. 每24小时增量爬取
startPeriodicCrawl(24)
```

- 优点：高覆盖率、用户无感知
- 缺点：需要配置权限（已有）

### 阶段 3: 智能化（未来）

🔮 **基于用户行为的智能触发**

- 用户访问书签 → 实时刷新元数据
- 用户搜索 → 优先爬取搜索结果
- 用户标签分类 → 批量爬取同类书签

---

## 📊 各触发方式对比

| 触发方式 | 覆盖率 | 性能影响 | 用户感知 | 实施难度 | 状态 |
| -------- | ------ | -------- | -------- | -------- | ---- |
| 手动触发 | 低     | 无       | 高       | ⭐       | ✅   |
| 智能推荐 | 中     | 低       | 无       | ⭐⭐     | ✅   |
| 新增监听 | 中     | 低       | 无       | ⭐⭐     | 🔮   |
| 定时爬取 | 高     | 低       | 无       | ⭐⭐     | 🔮   |
| 页面打开 | 中     | 低       | 无       | ⭐⭐     | 🔮   |
| 空闲触发 | 高     | 无       | 无       | ⭐⭐⭐   | 🔮   |

---

## 🔧 实施步骤

### 立即可用（5分钟）

1. **手动测试**
   - 参考 [快速测试指南](./本地化爬取-快速测试.md)
   - 在控制台手动触发

### 推荐集成（30分钟）

2. **集成到 background.js**

```typescript
// frontend/background.js

// 导入触发器
import {
  startAutocrawlOnBookmarkAdd,
  startPeriodicCrawl,
  crawlUnprocessedBookmarks
} from './src/services/bookmark-crawler-trigger'

// Service Worker 启动时
chrome.runtime.onInstalled.addListener(() => {
  console.log('🚀 AcuityBookmarks 已安装/更新')

  // 1. 启动书签新增监听
  startAutocrawlOnBookmarkAdd()

  // 2. 启动定时爬取（每24小时）
  startPeriodicCrawl(24)

  // 3. 首次安装时，爬取前100个书签
  crawlUnprocessedBookmarks(100)
    .then(() => console.log('✅ 初始爬取完成'))
    .catch(err => console.error('❌ 初始爬取失败', err))
})

// 监听定时任务
chrome.alarms.onAlarm.addListener(alarm => {
  if (alarm.name === 'bookmark-periodic-crawl') {
    console.log('⏰ 执行定时爬取')
    crawlUnprocessedBookmarks(100).catch(err =>
      console.error('❌ 定时爬取失败', err)
    )
  }
})
```

3. **重新构建和测试**

```bash
cd frontend
npm run build

# 重新加载扩展
# chrome://extensions → 重新加载
```

---

## 🧪 测试触发机制

### 测试新增监听

```javascript
// 1. 启动监听
startAutocrawlOnBookmarkAdd()

// 2. 添加一个测试书签
await chrome.bookmarks.create({
  title: 'Test Bookmark',
  url: 'https://github.com'
})

// 3. 等待1-2秒，查看日志
// 应该看到：🆕 检测到新书签: Test Bookmark
```

### 测试定时爬取

```javascript
// 1. 启动定时任务（1分钟测试）
startPeriodicCrawl(1 / 60) // 1分钟

// 2. 等待1分钟，查看日志
// 应该看到：⏰ 执行定时爬取

// 3. 停止测试
stopPeriodicCrawl()
```

### 测试增量爬取

```javascript
// 1. 查看当前状态
const status = await getCrawlStatus()
console.log('待爬取:', status.pending)

// 2. 执行增量爬取
await crawlUnprocessedBookmarks(10)

// 3. 再次查看状态
const newStatus = await getCrawlStatus()
console.log('待爬取:', newStatus.pending)
// 应该减少 10 个
```

---

## 📚 相关文档

- [快速测试指南](./本地化爬取-快速测试.md) - 5分钟验证功能
- [完整测试指南](./本地化爬取-测试指南.md) - 详细测试场景
- [集成指南](./本地化爬取-集成指南.md) - 完整集成步骤

---

## 💡 最佳实践

### ✅ 推荐

1. **启用书签新增监听** - 确保新书签及时爬取
2. **启用定时爬取** - 保持元数据新鲜度
3. **配置合理间隔** - 24小时一次，避免频繁

### ⚠️ 注意

1. **避免启动时大批量爬取** - 可能影响扩展启动速度
2. **使用低优先级** - 后台任务不应影响用户操作
3. **监控失败率** - 如果失败率过高，调整策略

### ❌ 不推荐

1. **频繁的定时任务** - 不要少于1小时间隔
2. **无限制的批量爬取** - 使用 `limit` 参数
3. **同步阻塞** - 所有爬取都应该是异步的

---

**现在你可以根据需求选择合适的触发方式了！** 🎉
