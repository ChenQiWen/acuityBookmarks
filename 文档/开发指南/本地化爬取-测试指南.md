# 本地化爬取 - 测试指南

## 🎯 测试目标

验证本地化爬取功能的完整性：

- ✅ Offscreen Document 是否正常工作
- ✅ 数据是否正确保存到 IndexedDB
- ✅ 队列和并发控制是否有效
- ✅ 大批量书签性能表现

---

## 🚀 快速开始

### 方式一：浏览器控制台（推荐）

#### 1. 加载扩展

```bash
# 构建扩展
cd /Users/cqw/Documents/github/acuityBookmarks/frontend
npm run build

# Chrome 浏览器
# 打开 chrome://extensions
# 启用"开发者模式"
# 点击"加载已解压的扩展程序"
# 选择 dist 文件夹
```

#### 2. 打开控制台

```
方式 A: 右键扩展图标 → 检查弹出内容
方式 B: 进入 Management 页面 → F12 打开控制台
方式 C: chrome://extensions → Service Worker → 控制台
```

#### 3. 导入测试模块

```javascript
// 在控制台中执行
const {
  crawlSingleBookmark,
  crawlMultipleBookmarks,
  getCrawlStatistics,
  getBookmarkMetadata
} = await import('./assets/app-services.CvlJmFwV.js')

// 或者使用全局快捷方式（如果已暴露）
const crawler = window.bookmarkCrawler
```

---

## 📝 测试场景

### 场景 1: 测试单个 URL

```javascript
// 测试爬取一个 URL
await crawler.testUrl('https://github.com')

// 查看结果
const metadata = await crawler.getStats()
console.log('爬取统计:', metadata)
```

**预期结果**：

- ✅ 控制台显示爬取进度
- ✅ 显示提取的标题、描述、keywords
- ✅ 无错误信息

---

### 场景 2: 爬取单个真实书签

```javascript
// 1. 获取一个书签
const bookmarks = await chrome.bookmarks.search({ url: 'https://github.com' })
const bookmark = bookmarks[0]

console.log('待测试书签:', bookmark)

// 2. 爬取
const { crawlSingleBookmark } = await import(
  './services/local-bookmark-crawler'
)
await crawlSingleBookmark(bookmark, { priority: 'high' })

// 3. 检查结果
const { getBookmarkMetadata } = await import(
  './services/local-bookmark-crawler'
)
const metadata = await getBookmarkMetadata(bookmark.id)

console.log('爬取元数据:', metadata)
console.log('✅ 页面标题:', metadata?.pageTitle)
console.log('✅ 描述:', metadata?.description)
console.log('✅ 关键词:', metadata?.keywords)
console.log('✅ OG 图片:', metadata?.ogImage)
```

**预期结果**：

```javascript
{
  bookmarkId: "123",
  url: "https://github.com",
  pageTitle: "GitHub: Let's build from here",
  description: "GitHub is where over 100 million developers...",
  keywords: "git,github,code,repository",
  ogTitle: "GitHub",
  ogDescription: "...",
  ogImage: "https://github.githubassets.com/...",
  status: "success",
  httpStatus: 200,
  lastCrawled: 1697123456789,
  crawlSuccess: true
}
```

---

### 场景 3: 批量爬取（10条）

```javascript
// 1. 获取 10 个书签
const allBookmarks = await chrome.bookmarks.search({})
const testBookmarks = allBookmarks
  .filter(b => b.url) // 只要有 URL 的
  .slice(0, 10)

console.log(`📚 准备爬取 ${testBookmarks.length} 个书签`)

// 2. 批量爬取
const { crawlMultipleBookmarks } = await import(
  './services/local-bookmark-crawler'
)

await crawlMultipleBookmarks(testBookmarks, {
  priority: 'normal',
  onProgress: (completed, total) => {
    console.log(`📊 进度: ${completed}/${total}`)
  },
  onComplete: results => {
    const success = results.filter(r => r.success).length
    console.log(`✅ 完成: ${success}/${results.length}`)
    console.log('详细结果:', results)
  }
})

// 3. 查看统计
const { getCrawlStatistics } = await import('./services/local-bookmark-crawler')
const stats = await getCrawlStatistics()
console.log('📊 爬取统计:', stats)
```

**预期输出**：

```
📚 准备爬取 10 个书签
📊 进度: 1/10
📊 进度: 2/10
...
📊 进度: 10/10
✅ 完成: 9/10

📊 爬取统计: {
  total: 10,
  withMetadata: 9,
  failed: 1,
  pending: 0,
  expired: 0
}
```

---

### 场景 4: 增量爬取未处理的书签

```javascript
// 使用触发器工具
const { crawlUnprocessedBookmarks, getCrawlStatus } = await import(
  './services/bookmark-crawler-trigger'
)

// 1. 查看当前状态
const status = await getCrawlStatus()
console.log('📊 当前状态:', status)
/*
{
  total: 1523,          // 总书签数
  withMetadata: 234,    // 已有元数据
  pending: 1289,        // 待爬取
  expired: 45,          // 过期需重新爬取
  successRate: 95.5     // 成功率
}
*/

// 2. 爬取前 100 个未处理的
await crawlUnprocessedBookmarks(100)

// 3. 再次检查状态
const newStatus = await getCrawlStatus()
console.log('📊 更新后状态:', newStatus)
```

**预期行为**：

- ✅ 只爬取没有元数据或过期的书签
- ✅ 跳过已有元数据的书签
- ✅ 进度实时显示

---

### 场景 5: 性能测试（大批量）

```javascript
// ⚠️ 注意：这会爬取大量书签，建议在空闲时测试

// 1. 获取所有书签
const allBookmarks = await chrome.bookmarks.search({})
const urlBookmarks = allBookmarks.filter(b => b.url)

console.log(`📚 共 ${urlBookmarks.length} 个书签`)

// 2. 分批测试（每次 50 个）
const batchSize = 50
for (
  let i = 0;
  i < Math.min(10, Math.ceil(urlBookmarks.length / batchSize));
  i++
) {
  const batch = urlBookmarks.slice(i * batchSize, (i + 1) * batchSize)

  console.log(`\n🔄 批次 ${i + 1}: ${batch.length} 个书签`)
  const startTime = Date.now()

  await crawlMultipleBookmarks(batch, {
    priority: 'low',
    onProgress: (completed, total) => {
      if (completed % 10 === 0) {
        console.log(`  📊 ${completed}/${total}`)
      }
    }
  })

  const duration = Date.now() - startTime
  console.log(`  ⏱️ 耗时: ${(duration / 1000).toFixed(1)}秒`)
  console.log(`  ⚡ 平均: ${(duration / batch.length).toFixed(0)}ms/个`)

  // 批次间隔 5 秒
  await new Promise(resolve => setTimeout(resolve, 5000))
}

// 3. 最终统计
const finalStats = await getCrawlStatistics()
console.log('\n📊 最终统计:', finalStats)
```

**性能基准**（参考）：

- 单个书签: 500-2000ms
- 50 个书签: 30-60 秒
- 1000 个书签: 10-20 分钟

---

### 场景 6: 验证数据持久化

```javascript
// 1. 爬取一个书签
const bookmark = (await chrome.bookmarks.search({}))[0]
await crawlSingleBookmark(bookmark)

// 2. 检查 crawlMetadata 表
const { indexedDBManager } = await import('./infrastructure/indexeddb/manager')
await indexedDBManager.initialize()

const metadata = await indexedDBManager.getCrawlMetadata(bookmark.id)
console.log('✅ crawlMetadata 表:', metadata)

// 3. 检查 bookmarks 表的关联字段
const bookmarkRecord = await indexedDBManager.getBookmarkById(bookmark.id)
console.log('✅ bookmarks 表关联字段:')
console.log('  hasMetadata:', bookmarkRecord.hasMetadata)
console.log('  metadataUpdatedAt:', new Date(bookmarkRecord.metadataUpdatedAt))
console.log('  metaTitleLower:', bookmarkRecord.metaTitleLower)
console.log('  metaDescriptionLower:', bookmarkRecord.metaDescriptionLower)
console.log('  metaKeywordsTokens:', bookmarkRecord.metaKeywordsTokens)
console.log('  metaBoost:', bookmarkRecord.metaBoost)

// 4. 验证搜索增强
const searchResults = await indexedDBManager.searchBookmarks({
  query: bookmarkRecord.metaKeywordsTokens[0], // 用第一个关键词搜索
  limit: 10
})
console.log('✅ 搜索增强测试:', searchResults.length, '个结果')
```

**预期结果**：

- ✅ `crawlMetadata` 表有完整数据
- ✅ `bookmarks` 表的 `hasMetadata` = true
- ✅ 派生字段（metaTitleLower 等）已填充
- ✅ 使用关键词可以搜索到该书签

---

## 🔍 调试技巧

### 1. 查看 Offscreen Document 状态

```javascript
// 检查 Offscreen Document 是否创建
chrome.offscreen.hasDocument().then(exists => {
  console.log('Offscreen Document 存在:', exists)
})
```

### 2. 监控爬取日志

```javascript
// 启用详细日志
localStorage.setItem('logLevel', 'debug')

// 查看所有日志
console.log(window.__logs || [])
```

### 3. 检查队列状态

```javascript
// 查看任务调度器状态
const { crawlTaskScheduler } = await import('./services/crawl-task-scheduler')

console.log('队列状态:')
console.log('  排队中:', crawlTaskScheduler.getPendingCount())
console.log('  执行中:', crawlTaskScheduler.getRunningCount())
console.log('  已完成:', crawlTaskScheduler.getCompletedCount())
```

### 4. 清除缓存重新测试

```javascript
// 清除特定书签的元数据
const { deleteBookmarkMetadata } = await import(
  './services/local-bookmark-crawler'
)
await deleteBookmarkMetadata('bookmark-id-here')

// 清除所有爬取数据
const allMetadata = await indexedDBManager.getAllCrawlMetadata()
for (const meta of allMetadata) {
  await indexedDBManager.deleteCrawlMetadata(meta.bookmarkId)
}
console.log('✅ 已清除所有爬取数据')
```

---

## 🐛 常见问题排查

### 问题 1: 爬取没有反应

**排查步骤**：

```javascript
// 1. 检查 Offscreen Document
const hasOffscreen = await chrome.offscreen.hasDocument()
console.log('Offscreen 存在:', hasOffscreen)

// 2. 检查权限
console.log('Offscreen 权限:', chrome.offscreen !== undefined)

// 3. 手动测试 Offscreen
const { extractMetaInOffscreen } = await import('./page-fetcher')
const html = '<html><head><title>Test</title></head></html>'
const result = await extractMetaInOffscreen(html)
console.log('Offscreen 测试:', result)
```

### 问题 2: 数据没有保存

**排查步骤**：

```javascript
// 1. 检查 IndexedDB 初始化
const { indexedDBManager } = await import('./infrastructure/indexeddb/manager')
await indexedDBManager.initialize()
console.log('IndexedDB 已初始化')

// 2. 检查表是否存在
const health = await indexedDBManager.checkDatabaseHealth()
console.log('数据库健康:', health)

// 3. 手动保存测试
await indexedDBManager.saveCrawlMetadata({
  bookmarkId: 'test-123',
  url: 'https://test.com',
  pageTitle: 'Test Title',
  description: 'Test Description',
  source: 'crawler',
  status: 'success',
  updatedAt: Date.now(),
  version: '2.0'
})
console.log('✅ 手动保存成功')

// 4. 读取验证
const saved = await indexedDBManager.getCrawlMetadata('test-123')
console.log('读取结果:', saved)
```

### 问题 3: 爬取很慢或卡住

**排查步骤**：

```javascript
// 1. 检查配置
const { CRAWLER_CONFIG } = await import('./config/constants')
console.log('爬取配置:', CRAWLER_CONFIG)

// 2. 调整并发
CRAWLER_CONFIG.CONCURRENCY = 5 // 增加并发数
CRAWLER_CONFIG.BATCH_SIZE = 20 // 增加批量大小

// 3. 禁用空闲调度（测试用）
CRAWLER_CONFIG.USE_IDLE_SCHEDULING = false

// 4. 查看性能统计
const { crawlTaskScheduler } = await import('./services/crawl-task-scheduler')
const stats = crawlTaskScheduler.getStatistics()
console.log('性能统计:', stats)
```

---

## 📊 测试检查清单

### 基础功能 ✅

- [ ] 单个 URL 爬取成功
- [ ] 批量爬取（10个）成功
- [ ] 数据保存到 `crawlMetadata` 表
- [ ] `bookmarks` 表关联字段更新
- [ ] 搜索功能增强生效

### 性能测试 ✅

- [ ] 50 个书签 < 60 秒
- [ ] 100 个书签 < 3 分钟
- [ ] 1000 个书签 < 20 分钟
- [ ] 内存占用 < 100MB

### 边界测试 ✅

- [ ] 无效 URL 正确处理
- [ ] 404/500 错误处理
- [ ] 超时处理
- [ ] CORS 错误处理
- [ ] 重复 URL 去重

### 数据一致性 ✅

- [ ] 断点续爬（刷新页面后继续）
- [ ] 并发写入无冲突
- [ ] 数据不丢失
- [ ] 关联关系正确

---

## 🎯 自动化测试脚本

```javascript
// 完整测试套件
async function runFullTest() {
  console.log('🧪 开始完整测试...\n')

  // 导入模块
  const { crawlSingleBookmark, crawlMultipleBookmarks, getCrawlStatistics } =
    await import('./services/local-bookmark-crawler')
  const { indexedDBManager } = await import(
    './infrastructure/indexeddb/manager'
  )
  await indexedDBManager.initialize()

  // 1. 单个爬取测试
  console.log('📝 测试 1: 单个爬取')
  const bookmarks = await chrome.bookmarks.search({})
  const testBookmark = bookmarks.find(b => b.url)

  if (testBookmark) {
    await crawlSingleBookmark(testBookmark)
    const metadata = await indexedDBManager.getCrawlMetadata(testBookmark.id)
    console.log(metadata ? '✅ 通过' : '❌ 失败')
  }

  // 2. 批量爬取测试
  console.log('\n📝 测试 2: 批量爬取')
  const batchBookmarks = bookmarks.filter(b => b.url).slice(0, 5)
  await crawlMultipleBookmarks(batchBookmarks)

  let batchSuccess = 0
  for (const b of batchBookmarks) {
    const meta = await indexedDBManager.getCrawlMetadata(b.id)
    if (meta) batchSuccess++
  }
  console.log(`✅ ${batchSuccess}/${batchBookmarks.length} 成功`)

  // 3. 统计测试
  console.log('\n📝 测试 3: 统计信息')
  const stats = await getCrawlStatistics()
  console.log('📊 统计:', stats)
  console.log(stats.total > 0 ? '✅ 通过' : '❌ 失败')

  // 4. 数据一致性测试
  console.log('\n📝 测试 4: 数据一致性')
  if (testBookmark) {
    const bookmark = await indexedDBManager.getBookmarkById(testBookmark.id)
    console.log('hasMetadata:', bookmark.hasMetadata)
    console.log('metaTitleLower:', bookmark.metaTitleLower)
    console.log(bookmark.hasMetadata ? '✅ 通过' : '❌ 失败')
  }

  console.log('\n🎉 测试完成！')
}

// 执行测试
runFullTest().catch(console.error)
```

---

## 📚 相关文档

- [本地化爬取架构方案](./本地化爬取架构方案.md)
- [本地化爬取-问题解答](./本地化爬取-问题解答.md)
- [本地化爬取-实施完成报告](./本地化爬取-实施完成报告.md)

---

**测试愉快！🎉**
