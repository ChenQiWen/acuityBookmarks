# æœ¬åœ°åŒ–ä¹¦ç­¾çˆ¬å–æ¶æ„æ–¹æ¡ˆ

## ğŸ¯ æ ¸å¿ƒç›®æ ‡

1. **éšç§ä¼˜å…ˆ**ï¼š100% å®¢æˆ·ç«¯æ‰§è¡Œï¼Œé›¶æ•°æ®ä¸Šä¼ 
2. **æ€§èƒ½æè‡´**ï¼š1000+ ä¹¦ç­¾æµç•…å¤„ç†ï¼Œä¸å½±å“ä¸»æµç¨‹
3. **ä½“éªŒä¼˜ç§€**ï¼šåå°é™é»˜æ‰§è¡Œï¼Œæ¸è¿›å¼æ•°æ®å‘ˆç°
4. **æ¶æ„æ¸…æ™°**ï¼šé˜Ÿåˆ—ã€ç¼“å­˜ã€è°ƒåº¦ã€æŒä¹…åŒ–åˆ†å±‚è®¾è®¡

---

## ğŸ“Š å½“å‰æ¶æ„åˆ†æ

### é—®é¢˜è¯Šæ–­

```
å½“å‰æµç¨‹ï¼š
  Serverless Crawler (ä¼˜å…ˆ) âŒ ä¸Šä¼ æ•°æ®åˆ°åç«¯
         â†“ å¤±è´¥
  Local Crawler (é™çº§)  âš ï¸ ç›´æ¥ç”¨ DOMParserï¼Œæœªä½¿ç”¨ Offscreen
         â†“
  Offscreen Document  âŒ å·²å®ç°ä½†æœªä½¿ç”¨
```

### æ”¹è¿›ç›®æ ‡

```
æ–°æ¶æ„ï¼š
  Background/Management â† ç”¨æˆ·è§¦å‘
         â†“
  ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å™¨ (Task Queue Manager)
         â†“
  Offscreen Document Worker â† å”¯ä¸€çˆ¬å–å…¥å£
         â†“
  å¤šå±‚ç¼“å­˜ç³»ç»Ÿ (Memory + IndexedDB)
         â†“
  æ¸è¿›å¼æ•°æ®åŒæ­¥
```

---

## ğŸ—ï¸ æ–°æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·ç•Œé¢å±‚ (UI)                        â”‚
â”‚  Management / Side Panel / Popup                        â”‚
â”‚  - è§¦å‘çˆ¬å–ä»»åŠ¡                                          â”‚
â”‚  - å®æ—¶æ˜¾ç¤ºè¿›åº¦                                          â”‚
â”‚  - æ¸è¿›å¼æ•°æ®å‘ˆç°                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä»»åŠ¡è°ƒåº¦å±‚ (Task Scheduler)                 â”‚
â”‚  CrawlTaskScheduler                                     â”‚
â”‚  - ä»»åŠ¡ä¼˜å…ˆçº§é˜Ÿåˆ— (PriorityQueue)                       â”‚
â”‚  - ç©ºé—²æ—¶æ®µè°ƒåº¦ (requestIdleCallback)                   â”‚
â”‚  - å¹¶å‘æ§åˆ¶ (æ¯åŸŸå 1 ä¸ªï¼Œå…¨å±€ 2-3 ä¸ª)                  â”‚
â”‚  - æ–­ç‚¹ç»­çˆ¬ (æŒä¹…åŒ–é˜Ÿåˆ—çŠ¶æ€)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Offscreen Document æ‰§è¡Œå±‚                     â”‚
â”‚  OffscreenCrawlerWorker (page-fetcher.js å¢å¼ºç‰ˆ)        â”‚
â”‚  - ç½‘ç»œè¯·æ±‚ (fetch + CORS å¤„ç†)                         â”‚
â”‚  - HTML è§£æ (DOMParser in Offscreen)                   â”‚
â”‚  - Robots.txt æ£€æŸ¥                                       â”‚
â”‚  - åŸŸåçº§åˆ«é™æµ (1ç§’é—´éš”)                               â”‚
â”‚  - è¶…æ—¶æ§åˆ¶ (10ç§’)                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å¤šå±‚ç¼“å­˜ç³»ç»Ÿ (Cache Layer)                  â”‚
â”‚  L1: å†…å­˜ç¼“å­˜ (LRU, 500æ¡, 5åˆ†é’Ÿ)                       â”‚
â”‚  L2: IndexedDB æŒä¹…åŒ–ç¼“å­˜ (30å¤© TTL)                    â”‚
â”‚  - URLå»é‡                                               â”‚
â”‚  - ç‰ˆæœ¬ç®¡ç†                                              â”‚
â”‚  - è¿‡æœŸæ¸…ç†                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            æ•°æ®åŒæ­¥å±‚ (Data Sync Layer)                  â”‚
â”‚  - å¢é‡åŒæ­¥åˆ°æœç´¢ç´¢å¼•                                    â”‚
â”‚  - é€šçŸ¥ UI æ›´æ–°                                          â”‚
â”‚  - ç»Ÿè®¡æ•°æ®æ›´æ–°                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ä»»åŠ¡é˜Ÿåˆ—ç®¡ç†å™¨ (CrawlTaskScheduler)

#### æ ¸å¿ƒèŒè´£

- ä»»åŠ¡å…¥é˜Ÿ/å‡ºé˜Ÿ
- ä¼˜å…ˆçº§ç®¡ç†
- å¹¶å‘æ§åˆ¶
- æ–­ç‚¹ç»­çˆ¬
- çŠ¶æ€æŒä¹…åŒ–

#### æ•°æ®ç»“æ„

```typescript
interface CrawlTask {
  id: string // ä»»åŠ¡ID (URL hash)
  url: string // ä¹¦ç­¾URL
  bookmarkId: string // ä¹¦ç­¾ID
  priority: number // ä¼˜å…ˆçº§ (0-100)
  status: 'pending' | 'running' | 'success' | 'failed' | 'paused'
  retryCount: number // é‡è¯•æ¬¡æ•°
  createdAt: number // åˆ›å»ºæ—¶é—´
  startedAt?: number // å¼€å§‹æ—¶é—´
  finishedAt?: number // å®Œæˆæ—¶é—´
  error?: string // é”™è¯¯ä¿¡æ¯
}

interface QueueState {
  tasks: CrawlTask[] // ä»»åŠ¡åˆ—è¡¨
  runningTasks: Map<string, CrawlTask> // è¿è¡Œä¸­ä»»åŠ¡
  domainLastAccess: Map<string, number> // åŸŸåæœ€åè®¿é—®æ—¶é—´
  statistics: {
    total: number // æ€»ä»»åŠ¡æ•°
    completed: number // å·²å®Œæˆ
    failed: number // å·²å¤±è´¥
    pending: number // å¾…å¤„ç†
  }
}
```

#### ä¼˜å…ˆçº§ç­–ç•¥

```typescript
/**
 * ä¼˜å…ˆçº§è®¡ç®—å…¬å¼
 * priority = baseScore + recencyBonus + accessBonus + manualBonus
 */
function calculatePriority(bookmark: Bookmark): number {
  let priority = 50 // åŸºç¡€åˆ†æ•°

  // 1. æœ€è¿‘æ·»åŠ çš„ä¹¦ç­¾ä¼˜å…ˆ (0-20åˆ†)
  const daysSinceAdded =
    (Date.now() - bookmark.dateAdded) / (1000 * 60 * 60 * 24)
  if (daysSinceAdded < 7) priority += 20
  else if (daysSinceAdded < 30) priority += 10

  // 2. æœ€è¿‘è®¿é—®çš„ä¹¦ç­¾ä¼˜å…ˆ (0-20åˆ†)
  if (bookmark.dateLastUsed) {
    const daysSinceUsed =
      (Date.now() - bookmark.dateLastUsed) / (1000 * 60 * 60 * 24)
    if (daysSinceUsed < 1) priority += 20
    else if (daysSinceUsed < 7) priority += 10
  }

  // 3. ç”¨æˆ·æ‰‹åŠ¨è§¦å‘çš„ä¼˜å…ˆ (0-10åˆ†)
  if (bookmark.manualTrigger) priority += 10

  return priority
}
```

#### å¹¶å‘æ§åˆ¶ç­–ç•¥

```typescript
class ConcurrencyController {
  private readonly MAX_GLOBAL_CONCURRENT = 2 // å…¨å±€æœ€å¤š2ä¸ªå¹¶å‘
  private readonly MAX_PER_DOMAIN_CONCURRENT = 1 // æ¯åŸŸåæœ€å¤š1ä¸ª
  private readonly MIN_DOMAIN_INTERVAL_MS = 1000 // åŸŸåé—´éš”1ç§’

  private runningCount = 0
  private domainRunning = new Map<string, number>()
  private domainLastAccess = new Map<string, number>()

  canStartTask(url: string): boolean {
    const domain = new URL(url).hostname

    // æ£€æŸ¥å…¨å±€å¹¶å‘
    if (this.runningCount >= this.MAX_GLOBAL_CONCURRENT) return false

    // æ£€æŸ¥åŸŸåå¹¶å‘
    if (
      (this.domainRunning.get(domain) || 0) >= this.MAX_PER_DOMAIN_CONCURRENT
    ) {
      return false
    }

    // æ£€æŸ¥åŸŸåé—´éš”
    const lastAccess = this.domainLastAccess.get(domain) || 0
    if (Date.now() - lastAccess < this.MIN_DOMAIN_INTERVAL_MS) return false

    return true
  }

  startTask(url: string): void {
    const domain = new URL(url).hostname
    this.runningCount++
    this.domainRunning.set(domain, (this.domainRunning.get(domain) || 0) + 1)
    this.domainLastAccess.set(domain, Date.now())
  }

  finishTask(url: string): void {
    const domain = new URL(url).hostname
    this.runningCount--
    this.domainRunning.set(domain, (this.domainRunning.get(domain) || 1) - 1)
  }
}
```

---

### 2. Offscreen Document çˆ¬è™«å·¥ä½œå™¨

#### å¢å¼ºçš„ page-fetcher.js

```javascript
/**
 * ğŸ¯ æœ¬åœ°åŒ–çˆ¬è™« - å®Œå…¨åŸºäº Offscreen Document
 *
 * æ ¸å¿ƒç‰¹æ€§ï¼š
 * - 100% å®¢æˆ·ç«¯æ‰§è¡Œ
 * - Offscreen ç¯å¢ƒä¸­è§£æ HTML
 * - åŸŸåçº§åˆ«é™æµ
 * - Robots.txt å°Šé‡
 * - è¶…æ—¶ä¿æŠ¤
 * - é”™è¯¯é™çº§
 */

// === é…ç½®å¸¸é‡ ===
const MIN_DOMAIN_INTERVAL_MS = 1000 // 1ç§’
const REQUEST_TIMEOUT_MS = 10000 // 10ç§’
const MAX_RETRIES = 2 // æœ€å¤šé‡è¯•2æ¬¡

// === åŸŸåè®¿é—®è®°å½• ===
const DOMAIN_LAST_ACCESS = new Map()
const ROBOTS_CACHE = new Map()

// === 1. åŸŸåé™æµ ===
async function waitForDomainSlot(domain) {
  const last = DOMAIN_LAST_ACCESS.get(domain) || 0
  const now = Date.now()
  const diff = now - last

  if (diff < MIN_DOMAIN_INTERVAL_MS) {
    await new Promise(r => setTimeout(r, MIN_DOMAIN_INTERVAL_MS - diff))
  }

  DOMAIN_LAST_ACCESS.set(domain, Date.now())
}

// === 2. Robots.txt æ£€æŸ¥ ===
async function checkRobotsTxt(url) {
  const domain = new URL(url).hostname

  // æ£€æŸ¥ç¼“å­˜
  const cached = ROBOTS_CACHE.get(domain)
  if (cached && Date.now() - cached.timestamp < 24 * 60 * 60 * 1000) {
    return cached.allowed
  }

  try {
    const robotsUrl = `https://${domain}/robots.txt`
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 5000)

    const response = await fetch(robotsUrl, {
      signal: controller.signal,
      headers: { 'User-Agent': 'AcuityBookmarks-Extension/1.0' }
    })

    clearTimeout(timeoutId)

    let allowed = true
    if (response.ok) {
      const text = await response.text()
      // ç®€åŒ–è§£æï¼šæ£€æŸ¥æ˜¯å¦æœ‰ User-agent: * + Disallow: /
      if (/User-agent:\s*\*/i.test(text) && /Disallow:\s*\//i.test(text)) {
        allowed = false
      }
    }

    // ç¼“å­˜ç»“æœ
    ROBOTS_CACHE.set(domain, { allowed, timestamp: Date.now() })
    return allowed
  } catch (error) {
    // æ— æ³•è·å–åˆ™é»˜è®¤å…è®¸
    ROBOTS_CACHE.set(domain, { allowed: true, timestamp: Date.now() })
    return true
  }
}

// === 3. åˆ›å»º Offscreen Document ===
async function ensureOffscreenDocument() {
  try {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    if (chrome.offscreen && (await chrome.offscreen.hasDocument?.())) {
      return true
    }
  } catch (e) {
    // hasDocument å¯èƒ½ä¸å­˜åœ¨ï¼Œç»§ç»­å°è¯•åˆ›å»º
  }

  try {
    await chrome.offscreen.createDocument({
      url: 'offscreen.html',
      reasons: ['DOM_SCRAPING'],
      justification: 'Parse bookmark page metadata locally for privacy'
    })
    return true
  } catch (error) {
    console.error('[CrawlerWorker] Failed to create offscreen document:', error)
    return false
  }
}

// === 4. ä½¿ç”¨ Offscreen è§£æ HTML ===
async function parseHTMLInOffscreen(html, url) {
  await ensureOffscreenDocument()

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Offscreen parsing timeout'))
    }, 3000)

    chrome.runtime.sendMessage({ type: 'PARSE_HTML', html, url }, response => {
      clearTimeout(timeout)

      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError.message))
        return
      }

      resolve(response || {})
    })
  })
}

// === 5. é™çº§ï¼šæ­£åˆ™è¡¨è¾¾å¼è§£æ ===
function fallbackParse(html) {
  const extract = regex => {
    const match = html.match(regex)
    return match ? match[1].trim() : ''
  }

  return {
    title: extract(/<title[^>]*>([^<]*)<\/title>/i),
    description: extract(
      /<meta[^>]*name=["']description["'][^>]*content=["']([^"']+)["'][^>]*>/i
    ),
    keywords: extract(
      /<meta[^>]*name=["']keywords["'][^>]*content=["']([^"']+)["'][^>]*>/i
    ),
    ogTitle: extract(
      /<meta[^>]*property=["']og:title["'][^>]*content=["']([^"']+)["'][^>]*>/i
    ),
    ogDescription: extract(
      /<meta[^>]*property=["']og:description["'][^>]*content=["']([^"']+)["'][^>]*>/i
    ),
    ogImage: extract(
      /<meta[^>]*property=["']og:image["'][^>]*content=["']([^"']+)["'][^>]*>/i
    ),
    ogSiteName: extract(
      /<meta[^>]*property=["']og:site_name["'][^>]*content=["']([^"']+)["'][^>]*>/i
    )
  }
}

// === 6. æ ¸å¿ƒçˆ¬å–å‡½æ•° ===
export async function crawlBookmarkLocally(url, options = {}) {
  const {
    respectRobots = true,
    timeout = REQUEST_TIMEOUT_MS,
    retryCount = 0
  } = options

  const startTime = Date.now()
  const domain = new URL(url).hostname

  try {
    // Step 1: åŸŸåé™æµ
    await waitForDomainSlot(domain)

    // Step 2: Robots.txt æ£€æŸ¥
    if (respectRobots) {
      const robotsAllowed = await checkRobotsTxt(url)
      if (!robotsAllowed) {
        return {
          success: false,
          error: 'Blocked by robots.txt',
          robotsAllowed: false,
          duration: Date.now() - startTime
        }
      }
    }

    // Step 3: å‘èµ·ç½‘ç»œè¯·æ±‚
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), timeout)

    const response = await fetch(url, {
      method: 'GET',
      redirect: 'follow',
      signal: controller.signal,
      headers: {
        'User-Agent':
          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        Accept:
          'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
        'Cache-Control': 'no-cache'
      }
    })

    clearTimeout(timeoutId)

    // Step 4: æ£€æŸ¥å“åº”
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    const contentType = response.headers.get('content-type') || ''
    if (!/text\/html|application\/xhtml\+xml/i.test(contentType)) {
      throw new Error(`Unsupported content type: ${contentType}`)
    }

    // Step 5: è¯»å– HTML
    const html = await response.text()

    // Step 6: è§£æå…ƒæ•°æ®ï¼ˆä¼˜å…ˆ Offscreenï¼Œå¤±è´¥åˆ™é™çº§ï¼‰
    let metadata
    try {
      metadata = await parseHTMLInOffscreen(html, url)
    } catch (offscreenError) {
      console.warn(
        '[CrawlerWorker] Offscreen parsing failed, fallback to regex:',
        offscreenError
      )
      metadata = fallbackParse(html)
    }

    // Step 7: è¿”å›ç»“æœ
    return {
      success: true,
      url: response.url || url, // å¤„ç†é‡å®šå‘
      httpStatus: response.status,
      metadata,
      robotsAllowed: true,
      duration: Date.now() - startTime
    }
  } catch (error) {
    // é‡è¯•é€»è¾‘
    if (retryCount < MAX_RETRIES && shouldRetry(error)) {
      console.log(
        `[CrawlerWorker] Retry ${retryCount + 1}/${MAX_RETRIES}: ${url}`
      )
      await new Promise(r => setTimeout(r, 1000 * (retryCount + 1)))
      return crawlBookmarkLocally(url, {
        ...options,
        retryCount: retryCount + 1
      })
    }

    // è¿”å›å¤±è´¥ç»“æœ
    return {
      success: false,
      url,
      error: error.message || String(error),
      errorType: classifyError(error),
      duration: Date.now() - startTime
    }
  }
}

// === 7. é”™è¯¯åˆ†ç±» ===
function classifyError(error) {
  const message = error.message || String(error)

  if (message.includes('aborted') || message.includes('timeout')) {
    return 'timeout'
  }
  if (message.includes('CORS') || message.includes('blocked')) {
    return 'cors'
  }
  if (message.includes('Failed to fetch') || message.includes('NetworkError')) {
    return 'network'
  }
  if (message.includes('HTTP 4') || message.includes('HTTP 5')) {
    return 'http_error'
  }

  return 'unknown'
}

// === 8. åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯• ===
function shouldRetry(error) {
  const errorType = classifyError(error)
  return errorType === 'timeout' || errorType === 'network'
}

// === 9. ç»Ÿè®¡ä¿¡æ¯ ===
export function getCrawlerStats() {
  return {
    domainsCached: DOMAIN_LAST_ACCESS.size,
    robotsCached: ROBOTS_CACHE.size
  }
}

// === 10. æ¸…ç†ç¼“å­˜ ===
export function clearCrawlerCache() {
  DOMAIN_LAST_ACCESS.clear()
  ROBOTS_CACHE.clear()
}
```

#### å¢å¼ºçš„ offscreen.js

```javascript
/**
 * ğŸ¯ Offscreen Document - HTML è§£æå·¥ä½œå™¨
 *
 * èŒè´£ï¼š
 * - ä½¿ç”¨çœŸå® DOM ç¯å¢ƒè§£æ HTML
 * - æå–å®Œæ•´çš„å…ƒæ•°æ®
 * - é”™è¯¯å®¹é”™
 */

;(() => {
  // === è¾…åŠ©å‡½æ•°ï¼šè·å– meta æ ‡ç­¾å†…å®¹ ===
  function getMeta(doc, name) {
    const el1 = doc.querySelector(`meta[name="${name}"]`)
    const el2 = doc.querySelector(`meta[property="${name}"]`)
    return (
      el1?.getAttribute('content') ||
      el2?.getAttribute('content') ||
      ''
    ).trim()
  }

  // === è¾…åŠ©å‡½æ•°ï¼šå®‰å…¨è·å–æ–‡æœ¬å†…å®¹ ===
  function getTextContent(element) {
    return (element?.textContent || '').trim()
  }

  // === æ ¸å¿ƒè§£æå‡½æ•° ===
  function parseHTML(html, url) {
    try {
      const parser = new DOMParser()
      const doc = parser.parseFromString(html, 'text/html')

      // 1. åŸºç¡€å…ƒæ•°æ®
      const title = getTextContent(doc.querySelector('title'))
      const description = getMeta(doc, 'description')
      const keywords = getMeta(doc, 'keywords')

      // 2. Open Graph å…ƒæ•°æ®
      const ogTitle = getMeta(doc, 'og:title')
      const ogDescription = getMeta(doc, 'og:description')
      const ogImage = getMeta(doc, 'og:image')
      const ogSiteName = getMeta(doc, 'og:site_name')
      const ogType = getMeta(doc, 'og:type')

      // 3. Twitter Card å…ƒæ•°æ®
      const twitterCard = getMeta(doc, 'twitter:card')
      const twitterTitle = getMeta(doc, 'twitter:title')
      const twitterDescription = getMeta(doc, 'twitter:description')
      const twitterImage = getMeta(doc, 'twitter:image')

      // 4. ç½‘ç«™å›¾æ ‡
      const iconEl = doc.querySelector(
        'link[rel~="icon"], link[rel="shortcut icon"], link[rel="apple-touch-icon"]'
      )
      const iconHref = iconEl?.getAttribute('href') || ''

      // 5. è¯­è¨€
      const lang =
        doc.documentElement.lang ||
        doc.querySelector('meta[http-equiv="content-language"]')?.content ||
        ''

      // 6. ä½œè€…
      const author = getMeta(doc, 'author')

      return {
        // åŸºç¡€
        title,
        description,
        keywords,
        lang,
        author,

        // Open Graph
        ogTitle,
        ogDescription,
        ogImage,
        ogSiteName,
        ogType,

        // Twitter Card
        twitterCard,
        twitterTitle,
        twitterDescription,
        twitterImage,

        // å›¾æ ‡
        iconHref
      }
    } catch (error) {
      console.error('[Offscreen] Parse error:', error)
      return {}
    }
  }

  // === ç›‘å¬æ¶ˆæ¯ ===
  chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (msg?.type === 'PARSE_HTML') {
      try {
        const result = parseHTML(msg.html || '', msg.url || '')
        sendResponse(result)
      } catch (error) {
        console.error('[Offscreen] Message handler error:', error)
        sendResponse({})
      }
      return true // ä¿æŒæ¶ˆæ¯é€šé“æ‰“å¼€
    }
  })

  console.log('[Offscreen] Worker initialized')
})()
```

---

### 3. å¤šå±‚ç¼“å­˜ç³»ç»Ÿ

#### L1: å†…å­˜ç¼“å­˜ (LRU)

```typescript
/**
 * LRU å†…å­˜ç¼“å­˜
 * - æœ€å¤š 500 æ¡
 * - æ¯æ¡ 5 åˆ†é’Ÿ TTL
 * - å‡å°‘ IndexedDB è®¿é—®
 */
class LRUCache<K, V> {
  private cache = new Map<K, { value: V; timestamp: number }>()
  private readonly maxSize: number
  private readonly ttl: number

  constructor(maxSize = 500, ttl = 5 * 60 * 1000) {
    this.maxSize = maxSize
    this.ttl = ttl
  }

  get(key: K): V | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined

    // æ£€æŸ¥è¿‡æœŸ
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key)
      return undefined
    }

    // LRU: ç§»åˆ°æœ€å
    this.cache.delete(key)
    this.cache.set(key, entry)

    return entry.value
  }

  set(key: K, value: V): void {
    // åˆ é™¤æ—§å€¼
    this.cache.delete(key)

    // å¦‚æœæ»¡äº†ï¼Œåˆ é™¤æœ€è€çš„ï¼ˆç¬¬ä¸€ä¸ªï¼‰
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }

    // æ·»åŠ æ–°å€¼
    this.cache.set(key, { value, timestamp: Date.now() })
  }

  has(key: K): boolean {
    return this.get(key) !== undefined
  }

  clear(): void {
    this.cache.clear()
  }

  size(): number {
    return this.cache.size
  }
}
```

#### L2: IndexedDB æŒä¹…åŒ–ç¼“å­˜

```typescript
/**
 * IndexedDB ç¼“å­˜ç®¡ç†å™¨
 * - 30å¤© TTL
 * - URL å»é‡
 * - ç‰ˆæœ¬ç®¡ç†
 */
class CrawlCacheManager {
  private readonly DB_NAME = 'AcuityBookmarks_CrawlCache'
  private readonly STORE_NAME = 'crawlMetadata'
  private readonly TTL = 30 * 24 * 60 * 60 * 1000 // 30å¤©

  private db: IDBDatabase | null = null
  private memoryCache = new LRUCache<string, CrawlMetadata>()

  async initialize(): Promise<void> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.DB_NAME, 2)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => {
        this.db = request.result
        resolve()
      }

      request.onupgradeneeded = event => {
        const db = (event.target as IDBOpenDBRequest).result

        // åˆ›å»ºå¯¹è±¡å­˜å‚¨
        if (!db.objectStoreNames.contains(this.STORE_NAME)) {
          const store = db.createObjectStore(this.STORE_NAME, {
            keyPath: 'url'
          })

          // åˆ›å»ºç´¢å¼•
          store.createIndex('bookmarkId', 'bookmarkId', { unique: false })
          store.createIndex('domain', 'domain', { unique: false })
          store.createIndex('lastCrawled', 'lastCrawled', { unique: false })
          store.createIndex('expiresAt', 'expiresAt', { unique: false })
        }
      }
    })
  }

  // è·å–ç¼“å­˜ï¼ˆä¼˜å…ˆå†…å­˜ï¼Œå…¶æ¬¡ IndexedDBï¼‰
  async get(url: string): Promise<CrawlMetadata | null> {
    // L1: æ£€æŸ¥å†…å­˜ç¼“å­˜
    const cached = this.memoryCache.get(url)
    if (cached) {
      // æ£€æŸ¥è¿‡æœŸ
      if (cached.expiresAt > Date.now()) {
        return cached
      }
    }

    // L2: æ£€æŸ¥ IndexedDB
    const dbResult = await this.getFromDB(url)
    if (dbResult && dbResult.expiresAt > Date.now()) {
      // å›å¡«å†…å­˜ç¼“å­˜
      this.memoryCache.set(url, dbResult)
      return dbResult
    }

    return null
  }

  // ä¿å­˜åˆ°ç¼“å­˜
  async set(metadata: CrawlMetadata): Promise<void> {
    // è®¾ç½®è¿‡æœŸæ—¶é—´
    metadata.expiresAt = Date.now() + this.TTL
    metadata.lastCrawled = Date.now()

    // L1: ä¿å­˜åˆ°å†…å­˜
    this.memoryCache.set(metadata.url, metadata)

    // L2: ä¿å­˜åˆ° IndexedDB
    await this.saveToDB(metadata)
  }

  // æ‰¹é‡è·å–
  async getMany(urls: string[]): Promise<Map<string, CrawlMetadata>> {
    const result = new Map<string, CrawlMetadata>()

    for (const url of urls) {
      const metadata = await this.get(url)
      if (metadata) {
        result.set(url, metadata)
      }
    }

    return result
  }

  // æ¸…ç†è¿‡æœŸæ•°æ®
  async cleanExpired(): Promise<number> {
    if (!this.db) return 0

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.STORE_NAME], 'readwrite')
      const store = transaction.objectStore(this.STORE_NAME)
      const index = store.index('expiresAt')

      const range = IDBKeyRange.upperBound(Date.now())
      const request = index.openCursor(range)

      let count = 0
      request.onsuccess = () => {
        const cursor = request.result
        if (cursor) {
          cursor.delete()
          count++
          cursor.continue()
        } else {
          resolve(count)
        }
      }

      request.onerror = () => reject(request.error)
    })
  }

  private async getFromDB(url: string): Promise<CrawlMetadata | null> {
    if (!this.db) return null

    return new Promise(resolve => {
      const transaction = this.db!.transaction([this.STORE_NAME], 'readonly')
      const store = transaction.objectStore(this.STORE_NAME)
      const request = store.get(url)

      request.onsuccess = () => resolve(request.result || null)
      request.onerror = () => resolve(null)
    })
  }

  private async saveToDB(metadata: CrawlMetadata): Promise<void> {
    if (!this.db) return

    return new Promise((resolve, reject) => {
      const transaction = this.db!.transaction([this.STORE_NAME], 'readwrite')
      const store = transaction.objectStore(this.STORE_NAME)
      const request = store.put(metadata)

      request.onsuccess = () => resolve()
      request.onerror = () => reject(request.error)
    })
  }
}
```

---

### 4. ç©ºé—²è°ƒåº¦å™¨

```typescript
/**
 * ğŸ¯ ç©ºé—²è°ƒåº¦å™¨
 *
 * ç­–ç•¥ï¼š
 * - ä½¿ç”¨ requestIdleCallback åœ¨æµè§ˆå™¨ç©ºé—²æ—¶æ‰§è¡Œ
 * - æ£€æµ‹ç”¨æˆ·æ´»åŠ¨ï¼Œæš‚åœçˆ¬å–
 * - é¡µé¢å¯è§æ€§æ£€æµ‹
 * - ç”µæ± çŠ¶æ€æ£€æµ‹ï¼ˆå¯é€‰ï¼‰
 */
class IdleScheduler {
  private isUserActive = false
  private lastActivity = Date.now()
  private readonly USER_IDLE_THRESHOLD = 30 * 1000 // 30ç§’

  constructor() {
    this.setupActivityDetection()
    this.setupVisibilityDetection()
  }

  // è®¾ç½®æ´»åŠ¨æ£€æµ‹
  private setupActivityDetection() {
    const events = ['mousedown', 'mousemove', 'keydown', 'scroll', 'touchstart']

    const onActivity = () => {
      this.isUserActive = true
      this.lastActivity = Date.now()
    }

    events.forEach(event => {
      document.addEventListener(event, onActivity, { passive: true })
    })

    // å®šæœŸæ£€æŸ¥ç”¨æˆ·æ˜¯å¦ç©ºé—²
    setInterval(() => {
      if (Date.now() - this.lastActivity > this.USER_IDLE_THRESHOLD) {
        this.isUserActive = false
      }
    }, 5000)
  }

  // è®¾ç½®å¯è§æ€§æ£€æµ‹
  private setupVisibilityDetection() {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // é¡µé¢éšè—æ—¶å¯ä»¥æ›´æ¿€è¿›åœ°çˆ¬å–
        this.isUserActive = false
      }
    })
  }

  // è¯·æ±‚ç©ºé—²æ‰§è¡Œ
  requestIdleExecution<T>(
    callback: () => Promise<T>,
    options?: { timeout?: number }
  ): Promise<T> {
    return new Promise((resolve, reject) => {
      // å¦‚æœç”¨æˆ·æ´»è·ƒï¼Œç­‰å¾…ç©ºé—²
      if (this.isUserActive) {
        if (typeof requestIdleCallback !== 'undefined') {
          requestIdleCallback(
            async deadline => {
              try {
                const result = await callback()
                resolve(result)
              } catch (error) {
                reject(error)
              }
            },
            { timeout: options?.timeout || 5000 }
          )
        } else {
          // é™çº§ï¼šä½¿ç”¨ setTimeout
          setTimeout(async () => {
            try {
              const result = await callback()
              resolve(result)
            } catch (error) {
              reject(error)
            }
          }, 100)
        }
      } else {
        // ç”¨æˆ·ç©ºé—²ï¼Œç«‹å³æ‰§è¡Œ
        callback().then(resolve).catch(reject)
      }
    })
  }

  // æ£€æŸ¥æ˜¯å¦åº”è¯¥ç»§ç»­çˆ¬å–
  shouldContinueCrawling(): boolean {
    // ç”¨æˆ·æ´»è·ƒæ—¶æš‚åœ
    if (this.isUserActive) return false

    // é¡µé¢å¯è§æ—¶é™ä½ä¼˜å…ˆçº§
    if (!document.hidden) {
      // å¯ä»¥ç»§ç»­ï¼Œä½†åº”è¯¥é™ä½é¢‘ç‡
      return Date.now() - this.lastActivity > this.USER_IDLE_THRESHOLD
    }

    // é¡µé¢éšè—æ—¶å¯ä»¥ç»§ç»­
    return true
  }
}
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. URL å»é‡

```typescript
/**
 * URL æ ‡å‡†åŒ–å’Œå»é‡
 */
function normalizeURL(url: string): string {
  try {
    const parsed = new URL(url)

    // ç§»é™¤ç‰‡æ®µ
    parsed.hash = ''

    // ç§»é™¤å¸¸è§çš„è¿½è¸ªå‚æ•°
    const trackingParams = [
      'utm_source',
      'utm_medium',
      'utm_campaign',
      'ref',
      'source'
    ]
    trackingParams.forEach(param => {
      parsed.searchParams.delete(param)
    })

    // æ’åºæŸ¥è¯¢å‚æ•°ï¼ˆç¡®ä¿ä¸€è‡´æ€§ï¼‰
    const sortedParams = Array.from(parsed.searchParams.entries()).sort(
      (a, b) => a[0].localeCompare(b[0])
    )

    parsed.search = new URLSearchParams(sortedParams).toString()

    return parsed.toString()
  } catch {
    return url
  }
}

/**
 * URL åˆ†ç»„ï¼ˆå»é‡ï¼‰
 */
function groupBookmarksByURL(
  bookmarks: chrome.bookmarks.BookmarkTreeNode[]
): Map<string, chrome.bookmarks.BookmarkTreeNode[]> {
  const groups = new Map<string, chrome.bookmarks.BookmarkTreeNode[]>()

  for (const bookmark of bookmarks) {
    if (!bookmark.url) continue

    const normalizedURL = normalizeURL(bookmark.url)

    if (!groups.has(normalizedURL)) {
      groups.set(normalizedURL, [])
    }

    groups.get(normalizedURL)!.push(bookmark)
  }

  return groups
}
```

### 2. æ¸è¿›å¼æ•°æ®å‘ˆç°

```typescript
/**
 * ğŸ¯ æ¸è¿›å¼æ•°æ®åŒæ­¥
 *
 * ç­–ç•¥ï¼š
 * - æ¯çˆ¬å– N ä¸ªä¹¦ç­¾ï¼Œå°±æ›´æ–°ä¸€æ¬¡ UI
 * - ä½¿ç”¨ postMessage é€šçŸ¥ UI å±‚
 * - é¿å…é˜»å¡ä¸»çº¿ç¨‹
 */
class ProgressiveDataSync {
  private readonly UPDATE_THRESHOLD = 10 // æ¯ 10 ä¸ªæ›´æ–°ä¸€æ¬¡
  private updateQueue: CrawlMetadata[] = []

  // æ·»åŠ çˆ¬å–ç»“æœ
  add(metadata: CrawlMetadata) {
    this.updateQueue.push(metadata)

    if (this.updateQueue.length >= this.UPDATE_THRESHOLD) {
      this.flush()
    }
  }

  // ç«‹å³åˆ·æ–°
  async flush() {
    if (this.updateQueue.length === 0) return

    const batch = [...this.updateQueue]
    this.updateQueue = []

    // 1. æ‰¹é‡ä¿å­˜åˆ°ç¼“å­˜
    await Promise.all(batch.map(m => cacheManager.set(m)))

    // 2. é€šçŸ¥æœç´¢ç´¢å¼•æ›´æ–°
    await searchWorkerAdapter.updateDocuments(batch)

    // 3. é€šçŸ¥ UI æ›´æ–°
    this.notifyUI({
      type: 'CRAWL_PROGRESS',
      data: batch.map(m => ({
        bookmarkId: m.bookmarkId,
        title: m.title,
        description: m.description
      }))
    })
  }

  private notifyUI(message: any) {
    // é€šçŸ¥æ‰€æœ‰æ‰“å¼€çš„é¡µé¢
    chrome.runtime.sendMessage(message).catch(() => {
      // é¡µé¢å¯èƒ½æœªæ‰“å¼€ï¼Œå¿½ç•¥é”™è¯¯
    })
  }
}
```

### 3. æ–­ç‚¹ç»­çˆ¬

```typescript
/**
 * ğŸ¯ æŒä¹…åŒ–é˜Ÿåˆ—çŠ¶æ€
 *
 * åŠŸèƒ½ï¼š
 * - ä¿å­˜é˜Ÿåˆ—çŠ¶æ€åˆ° chrome.storage.local
 * - æ‰©å±•é‡å¯åæ¢å¤é˜Ÿåˆ—
 * - æ”¯æŒæš‚åœ/ç»§ç»­
 */
class PersistentQueue {
  private readonly STORAGE_KEY = 'crawl_queue_state'

  // ä¿å­˜é˜Ÿåˆ—çŠ¶æ€
  async saveState(state: QueueState): Promise<void> {
    try {
      await chrome.storage.local.set({
        [this.STORAGE_KEY]: {
          tasks: Array.from(state.tasks),
          statistics: state.statistics,
          timestamp: Date.now()
        }
      })
    } catch (error) {
      console.error('[PersistentQueue] Failed to save state:', error)
    }
  }

  // æ¢å¤é˜Ÿåˆ—çŠ¶æ€
  async loadState(): Promise<QueueState | null> {
    try {
      const result = await chrome.storage.local.get(this.STORAGE_KEY)
      const saved = result[this.STORAGE_KEY]

      if (!saved) return null

      // æ£€æŸ¥çŠ¶æ€æ˜¯å¦å¤ªæ—§ï¼ˆè¶…è¿‡7å¤©ï¼‰
      if (Date.now() - saved.timestamp > 7 * 24 * 60 * 60 * 1000) {
        await this.clearState()
        return null
      }

      return {
        tasks: saved.tasks || [],
        runningTasks: new Map(),
        domainLastAccess: new Map(),
        statistics: saved.statistics || {
          total: 0,
          completed: 0,
          failed: 0,
          pending: 0
        }
      }
    } catch (error) {
      console.error('[PersistentQueue] Failed to load state:', error)
      return null
    }
  }

  // æ¸…é™¤é˜Ÿåˆ—çŠ¶æ€
  async clearState(): Promise<void> {
    try {
      await chrome.storage.local.remove(this.STORAGE_KEY)
    } catch (error) {
      console.error('[PersistentQueue] Failed to clear state:', error)
    }
  }
}
```

---

## ğŸ¯ å®Œæ•´ä½¿ç”¨ç¤ºä¾‹

### åœ¨ Management é¡µé¢è§¦å‘æ‰¹é‡çˆ¬å–

```typescript
/**
 * ç”¨æˆ·ç‚¹å‡»"åˆ·æ–°æ‰€æœ‰ä¹¦ç­¾å…ƒæ•°æ®"æŒ‰é’®
 */
async function handleRefreshAllMetadata() {
  // 1. è·å–æ‰€æœ‰ä¹¦ç­¾
  const allBookmarks = await chrome.bookmarks.getTree()
  const flatBookmarks = flattenBookmarkTree(allBookmarks)
  const urlBookmarks = flatBookmarks.filter(b => b.url)

  // 2. æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
  const confirmed = await showConfirmDialog({
    title: 'åˆ·æ–°ä¹¦ç­¾å…ƒæ•°æ®',
    message: `å°†åœ¨åå°çˆ¬å– ${urlBookmarks.length} ä¸ªä¹¦ç­¾çš„å…ƒæ•°æ®ï¼Œé¢„è®¡éœ€è¦ ${estimateTime(urlBookmarks.length)} åˆ†é’Ÿ`,
    confirmText: 'å¼€å§‹åˆ·æ–°',
    cancelText: 'å–æ¶ˆ'
  })

  if (!confirmed) return

  // 3. å¯åŠ¨çˆ¬å–ä»»åŠ¡
  const taskId = await crawlTaskScheduler.scheduleBookmarksCrawl(urlBookmarks, {
    priority: 'normal',
    onProgress: progress => {
      // æ›´æ–°è¿›åº¦æ¡
      updateProgressBar(progress)
    },
    onComplete: stats => {
      // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
      showNotification({
        title: 'å…ƒæ•°æ®åˆ·æ–°å®Œæˆ',
        message: `æˆåŠŸ: ${stats.completed}, å¤±è´¥: ${stats.failed}`,
        type: 'success'
      })
    }
  })

  // 4. æ˜¾ç¤ºè¿›åº¦é¢æ¿
  showProgressPanel({
    taskId,
    onPause: () => crawlTaskScheduler.pauseTask(taskId),
    onResume: () => crawlTaskScheduler.resumeTask(taskId),
    onCancel: () => crawlTaskScheduler.cancelTask(taskId)
  })
}

function estimateTime(count: number): number {
  // è€ƒè™‘ï¼šæ¯ä¸ªä¹¦ç­¾å¹³å‡ 2 ç§’ï¼Œå¹¶å‘ 2 ä¸ªï¼Œæ‰¹æ¬¡é—´éš” 1.5 ç§’
  const avgTimePerBookmark = 2
  const concurrency = 2
  const batchInterval = 1.5
  const batchSize = 5

  const batches = Math.ceil(count / batchSize)
  const timeInSeconds =
    (count / concurrency) * avgTimePerBookmark + batches * batchInterval

  return Math.ceil(timeInSeconds / 60)
}
```

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### é¢„æœŸæ€§èƒ½ï¼ˆ1000æ¡ä¹¦ç­¾ï¼‰

| æŒ‡æ ‡             | æ•°å€¼     | è¯´æ˜                   |
| ---------------- | -------- | ---------------------- |
| **å»é‡åURLæ•°**  | ~700     | 30%é‡å¤ç‡              |
| **ç¼“å­˜å‘½ä¸­ç‡**   | 80%      | 30å¤©ç¼“å­˜               |
| **å®é™…çˆ¬å–æ•°**   | ~140     | ä»…çˆ¬æ–°å¢+è¿‡æœŸ          |
| **å¹³å‡å•æ¬¡è€—æ—¶** | 2ç§’      | åŒ…å«ç½‘ç»œ+è§£æ          |
| **å¹¶å‘æ•°**       | 2        | å…¨å±€é™åˆ¶               |
| **æ€»è€—æ—¶**       | ~2.5åˆ†é’Ÿ | 140 Ã· 2 Ã— 2 + æ‰¹æ¬¡é—´éš” |
| **å†…å­˜å ç”¨**     | <50MB    | LRU + æµå¼å¤„ç†         |
| **CPUå ç”¨**      | <5%      | ç©ºé—²è°ƒåº¦               |

### ç”¨æˆ·ä½“éªŒ

- âœ… **ä¸»æµç¨‹é›¶å½±å“**ï¼šåå°é™é»˜æ‰§è¡Œ
- âœ… **æ¸è¿›å¼å‘ˆç°**ï¼šæ¯10ä¸ªæ›´æ–°ä¸€æ¬¡UI
- âœ… **å¯ä¸­æ–­æ¢å¤**ï¼šæ”¯æŒæš‚åœ/ç»§ç»­
- âœ… **æ–­ç‚¹ç»­çˆ¬**ï¼šæ‰©å±•é‡å¯åè‡ªåŠ¨æ¢å¤
- âœ… **æ™ºèƒ½é™æµ**ï¼šç”¨æˆ·æ´»è·ƒæ—¶è‡ªåŠ¨é™é€Ÿ

---

## ğŸ”’ éšç§ä¿æŠ¤

### æ•°æ®æµå‘

```
ç”¨æˆ·ä¹¦ç­¾ (æœ¬åœ°)
    â†“
Chrome Extension (æœ¬åœ°)
    â†“
Offscreen Document (æœ¬åœ°)
    â†“
ç›®æ ‡ç½‘ç«™ (ç›´è¿ï¼ŒHTTPS)
    â†“
HTML å“åº” (æœ¬åœ°å¤„ç†)
    â†“
æå–å…ƒæ•°æ® (æœ¬åœ°)
    â†“
IndexedDB (æœ¬åœ°å­˜å‚¨)
    â†“
æœç´¢ç´¢å¼• (æœ¬åœ°)
```

### éšç§æ‰¿è¯º

- âœ… **é›¶æ•°æ®ä¸Šä¼ **ï¼šæ‰€æœ‰æ•°æ®æœ¬åœ°å¤„ç†
- âœ… **ç›´è¿ç›®æ ‡ç«™**ï¼šä¸ç»è¿‡ä»»ä½•ä¸­é—´æœåŠ¡å™¨
- âœ… **æœ¬åœ°å­˜å‚¨**ï¼šIndexedDB + chrome.storage.local
- âœ… **å¯å®¡è®¡**ï¼šå¼€æºä»£ç ï¼Œå¯éªŒè¯
- âœ… **ç”¨æˆ·æ§åˆ¶**ï¼šå¯éšæ—¶æš‚åœ/æ¸…é™¤

---

## ğŸš€ å®æ–½æ­¥éª¤

### Phase 1: æ ¸å¿ƒé‡æ„ï¼ˆ1-2å¤©ï¼‰

1. âœ… ä¿®æ”¹ `constants.ts`
   - `CRAWLER_CONFIG.MODE = 'local'`ï¼ˆå¼ºåˆ¶æœ¬åœ°æ¨¡å¼ï¼‰
2. âœ… é‡æ„ `page-fetcher.js`
   - å®ç°å®Œæ•´çš„æœ¬åœ°çˆ¬å–é€»è¾‘
   - å¢å¼º Offscreen æ¶ˆæ¯å¤„ç†
3. âœ… å¢å¼º `offscreen.js`
   - æå–æ›´å¤šå…ƒæ•°æ®å­—æ®µ
   - æ”¹è¿›é”™è¯¯å¤„ç†

### Phase 2: é˜Ÿåˆ—ç³»ç»Ÿï¼ˆ2-3å¤©ï¼‰

4. âœ… åˆ›å»º `CrawlTaskScheduler`
   - ä¼˜å…ˆçº§é˜Ÿåˆ—
   - å¹¶å‘æ§åˆ¶
   - çŠ¶æ€ç®¡ç†
5. âœ… åˆ›å»º `ConcurrencyController`
   - å…¨å±€é™æµ
   - åŸŸåé™æµ
   - é—´éš”æ§åˆ¶

### Phase 3: ç¼“å­˜ä¼˜åŒ–ï¼ˆ1-2å¤©ï¼‰

6. âœ… å®ç° `LRUCache`
   - å†…å­˜ç¼“å­˜å±‚
7. âœ… ä¼˜åŒ– `CrawlCacheManager`
   - ä¸¤å±‚ç¼“å­˜æ¶æ„
   - è¿‡æœŸæ¸…ç†

### Phase 4: è°ƒåº¦ä¼˜åŒ–ï¼ˆ1-2å¤©ï¼‰

8. âœ… åˆ›å»º `IdleScheduler`
   - ç©ºé—²æ£€æµ‹
   - æ´»åŠ¨æ£€æµ‹
   - å¯è§æ€§æ£€æµ‹
9. âœ… åˆ›å»º `PersistentQueue`
   - çŠ¶æ€æŒä¹…åŒ–
   - æ–­ç‚¹ç»­çˆ¬

### Phase 5: é›†æˆæµ‹è¯•ï¼ˆ1-2å¤©ï¼‰

10. âœ… ä¿®æ”¹ `lightweight-bookmark-enhancer.ts`
    - ç§»é™¤ Serverless è°ƒç”¨
    - ä½¿ç”¨æ–°çš„æœ¬åœ°çˆ¬å–ç³»ç»Ÿ
11. âœ… UI å±‚é›†æˆ
    - è¿›åº¦æ˜¾ç¤º
    - æ§åˆ¶é¢æ¿
    - é€šçŸ¥æç¤º

### Phase 6: å‹åŠ›æµ‹è¯•ï¼ˆ1å¤©ï¼‰

12. âœ… æµ‹è¯•åœºæ™¯
    - 100æ¡ä¹¦ç­¾
    - 500æ¡ä¹¦ç­¾
    - 1000æ¡ä¹¦ç­¾
    - 5000æ¡ä¹¦ç­¾
13. âœ… æ€§èƒ½ç›‘æ§
    - å†…å­˜å ç”¨
    - CPUä½¿ç”¨ç‡
    - ç½‘ç»œæµé‡
    - ç”¨æˆ·æ„ŸçŸ¥å»¶è¿Ÿ

---

## ğŸ“ é…ç½®å‚æ•°å‚è€ƒ

### æ¨èé…ç½®ï¼ˆ.envï¼‰

```bash
# çˆ¬è™«æ¨¡å¼ï¼ˆå¼ºåˆ¶æœ¬åœ°ï¼‰
VITE_CRAWLER_MODE=local

# å¹¶å‘æ§åˆ¶
VITE_CRAWLER_CONCURRENCY=2
VITE_CRAWLER_PER_DOMAIN_CONCURRENCY=1

# æ‰¹é‡å¤„ç†
VITE_CRAWLER_BATCH_SIZE=5
VITE_CRAWLER_BATCH_INTERVAL_MS=1500

# é¢‘ç‡é™åˆ¶
VITE_CRAWLER_DAILY_LIMIT=1000

# è°ƒåº¦ç­–ç•¥
VITE_CRAWLER_USE_IDLE_SCHEDULING=true
VITE_CRAWLER_IDLE_DELAY_MS=3000

# Robots.txt
VITE_CRAWLER_RESPECT_ROBOTS=true
```

---

## ğŸ‰ é¢„æœŸæ•ˆæœ

### æŠ€æœ¯æŒ‡æ ‡

- âœ… **100% æœ¬åœ°åŒ–**ï¼šæ— ä»»ä½•æ•°æ®ä¸Šä¼ 
- âœ… **é«˜æ€§èƒ½**ï¼š1000ä¹¦ç­¾ < 3åˆ†é’Ÿ
- âœ… **ä½èµ„æºå ç”¨**ï¼šå†…å­˜ < 50MBï¼ŒCPU < 5%
- âœ… **é«˜å¯é æ€§**ï¼šæ–­ç‚¹ç»­çˆ¬ï¼Œè‡ªåŠ¨é‡è¯•
- âœ… **ç”¨æˆ·å‹å¥½**ï¼šæ¸è¿›å¼å‘ˆç°ï¼Œå¯æ§åˆ¶

### ç”¨æˆ·ä½“éªŒ

- âœ… **æ— æ„ŸçŸ¥**ï¼šåå°è‡ªåŠ¨æ‰§è¡Œ
- âœ… **å¯æ„ŸçŸ¥**ï¼šå®æ—¶è¿›åº¦åé¦ˆ
- âœ… **å¯æ§åˆ¶**ï¼šæš‚åœ/ç»§ç»­/å–æ¶ˆ
- âœ… **å¯ä¿¡ä»»**ï¼šéšç§ä¿æŠ¤ï¼Œæ•°æ®æœ¬åœ°

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-12  
**çŠ¶æ€**: âœ… å¾…å®æ–½
