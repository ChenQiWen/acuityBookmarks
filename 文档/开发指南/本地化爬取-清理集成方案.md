# æœ¬åœ°åŒ–çˆ¬å– - æ¸…ç†ä¸é›†æˆæ–¹æ¡ˆ

## ğŸ“‹ ç°çŠ¶åˆ†æ

### ç°æœ‰å®ç°çš„é—®é¢˜

```typescript
// âŒ é—®é¢˜1: ä½¿ç”¨ Serverless Crawlerï¼Œä¸Šä¼ æ•°æ®åˆ°æœåŠ¡å™¨
// frontend/src/services/lightweight-bookmark-enhancer.ts
import { serverlessCrawlerClient } from './serverless-crawler-client'

const result = await serverlessCrawlerClient.crawlBookmark(bookmark)
// æ•°æ®æµå‘: å®¢æˆ·ç«¯ â†’ åç«¯ â†’ ç›®æ ‡ç½‘ç«™ â†’ åç«¯ â†’ å®¢æˆ·ç«¯

// âŒ é—®é¢˜2: ç‹¬ç«‹çš„ IndexedDBï¼Œä¸ä¸»æ•°æ®åº“åˆ†ç¦»
const DB_NAME = 'AcuityBookmarks_LightweightCache' // ç‹¬ç«‹æ•°æ®åº“
const STORE_NAME = 'bookmark_metadata' // ç‹¬ç«‹è¡¨

// âŒ é—®é¢˜3: æ•°æ®æœªä¸ä¸»ä¹¦ç­¾è¡¨å…³è”
// çˆ¬å–çš„æ•°æ®ä¿å­˜åœ¨ç‹¬ç«‹æ•°æ®åº“ä¸­ï¼Œæ²¡æœ‰æ›´æ–° bookmarks è¡¨çš„å…³è”å­—æ®µ
```

### ç»Ÿä¸€çš„æ•°æ®åº“æ¶æ„

```typescript
// âœ… æ­£ç¡®çš„æ¶æ„
// ä¸»æ•°æ®åº“: AcuityBookmarksDB (version 7)

// è¡¨1: bookmarks - ä¹¦ç­¾è®°å½•
interface BookmarkRecord {
  id: string
  title: string
  url?: string

  // å…ƒæ•°æ®å…³è”å­—æ®µ
  hasMetadata?: boolean // æ˜¯å¦æœ‰çˆ¬å–å…ƒæ•°æ®
  metadataUpdatedAt?: number // å…ƒæ•°æ®æ›´æ–°æ—¶é—´
  metadataSource?: 'chrome' | 'crawler' | 'merged'

  // æ´¾ç”Ÿå­—æ®µï¼ˆç”¨äºæœç´¢å¢å¼ºï¼‰
  metaTitleLower?: string
  metaDescriptionLower?: string
  metaKeywordsTokens?: string[]
  metaBoost?: number
}

// è¡¨2: crawlMetadata - çˆ¬å–å…ƒæ•°æ®
interface CrawlMetadataRecord {
  bookmarkId: string // ä¸»é”®ï¼Œå…³è”åˆ° bookmarks.id
  url: string
  finalUrl?: string
  domain?: string

  // çˆ¬å–çš„å…ƒæ•°æ®
  pageTitle?: string
  description?: string
  keywords?: string
  ogTitle?: string
  ogDescription?: string
  ogImage?: string
  ogSiteName?: string

  // çŠ¶æ€
  source: 'chrome' | 'crawler' | 'merged'
  status?: 'success' | 'failed' | 'partial'
  httpStatus?: number
  lastCrawled?: number

  // ç»´æŠ¤
  updatedAt: number
  version: string
}
```

---

## ğŸ—‘ï¸ æ¸…ç†æ–¹æ¡ˆ

### ç¬¬ä¸€æ­¥ï¼šåˆ é™¤ Serverless Crawler

#### 1.1 åˆ é™¤æ–‡ä»¶

```bash
# åˆ é™¤æ•´ä¸ª serverless-crawler-client.ts
rm frontend/src/services/serverless-crawler-client.ts
```

#### 1.2 åˆ é™¤ç›¸å…³å¯¼å…¥

```typescript
// åœ¨æ‰€æœ‰æ–‡ä»¶ä¸­åˆ é™¤è¿™è¡Œ
import { serverlessCrawlerClient } from './serverless-crawler-client'
```

éœ€è¦æ£€æŸ¥çš„æ–‡ä»¶ï¼š

- `frontend/src/services/lightweight-bookmark-enhancer.ts` âœ… **å¿…é¡»ä¿®æ”¹**
- `frontend/src/services/smart-recommendation-engine.ts` ï¼ˆå¦‚æœæœ‰å¼•ç”¨ï¼‰
- å…¶ä»–å¯èƒ½çš„å¼•ç”¨

### ç¬¬äºŒæ­¥ï¼šæ¸…ç†ç‹¬ç«‹ IndexedDB

#### 2.1 ç§»é™¤ç‹¬ç«‹æ•°æ®åº“ä»£ç 

```typescript
// âŒ åˆ é™¤è¿™äº›ä»£ç ï¼ˆlightweight-bookmark-enhancer.tsï¼‰

const DB_NAME = 'AcuityBookmarks_LightweightCache'
const DB_VERSION = 1
const STORE_NAME = 'bookmark_metadata'

class LightweightBookmarkEnhancer {
  private db: IDBDatabase | null = null  // âŒ åˆ é™¤

  private async initDatabase(): Promise<void> {
    // âŒ æ•´ä¸ªæ–¹æ³•åˆ é™¤
  }

  private async saveToCacheInternal(metadata): Promise<void> {
    // âŒ æ•´ä¸ªæ–¹æ³•åˆ é™¤
  }

  private async getCachedMetadata(url): Promise<...> {
    // âŒ æ•´ä¸ªæ–¹æ³•åˆ é™¤
  }
}
```

#### 2.2 ä½¿ç”¨ç»Ÿä¸€çš„ IndexedDB Manager

```typescript
// âœ… ä½¿ç”¨ç»Ÿä¸€çš„ç®¡ç†å™¨
import { indexedDBManager } from '@/infrastructure/indexeddb/manager'
import type { CrawlMetadataRecord } from '@/infrastructure/indexeddb/schema'
```

### ç¬¬ä¸‰æ­¥ï¼šç§»é™¤æ··åˆæ¨¡å¼

```typescript
// âŒ åˆ é™¤æ··åˆçˆ¬å–é€»è¾‘

// ä¸å†éœ€è¦è¿™ç§æ¨¡å¼åˆ¤æ–­
if (CRAWLER_CONFIG.MODE === 'serverless' || CRAWLER_CONFIG.MODE === 'hybrid') {
  // Serverless çˆ¬å–
} else {
  // æœ¬åœ°çˆ¬å–
}

// âœ… ç»Ÿä¸€ä½¿ç”¨æœ¬åœ°çˆ¬å–
const result = await crawlBookmarkLocally(bookmark.url)
```

---

## ğŸ”§ é›†æˆæ–¹æ¡ˆ

### å®Œæ•´çš„æ–°æ¶æ„

```typescript
/**
 * ğŸ“ frontend/src/services/local-bookmark-crawler.ts
 *
 * æ–°çš„ç»Ÿä¸€çˆ¬è™«æœåŠ¡ï¼Œé›†æˆäº†ï¼š
 * - æœ¬åœ°çˆ¬å–ï¼ˆOffscreen Documentï¼‰
 * - ä»»åŠ¡è°ƒåº¦ï¼ˆé˜Ÿåˆ—ã€å¹¶å‘ã€ä¼˜å…ˆçº§ï¼‰
 * - æ•°æ®ä¿å­˜ï¼ˆç»Ÿä¸€ IndexedDBï¼‰
 * - å…³è”æ›´æ–°ï¼ˆbookmarks è¡¨ï¼‰
 */

import {
  crawlBookmarkLocally,
  type CrawlResult,
  type PageMetadata
} from './local-crawler-worker'
import { crawlTaskScheduler, type CrawlOptions } from './crawl-task-scheduler'
import { indexedDBManager } from '@/infrastructure/indexeddb/manager'
import type {
  CrawlMetadataRecord,
  BookmarkRecord
} from '@/infrastructure/indexeddb/schema'
import { logger } from '@/infrastructure/logging/logger'

// ==================== ä¿å­˜çˆ¬å–ç»“æœ ====================

/**
 * ä¿å­˜çˆ¬å–ç»“æœåˆ° IndexedDB
 */
export async function saveCrawlResult(
  bookmarkId: string,
  url: string,
  result: CrawlResult
): Promise<void> {
  try {
    if (!result.success || !result.metadata) {
      // ä¿å­˜å¤±è´¥è®°å½•
      await saveCrawlFailure(bookmarkId, url, result)
      return
    }

    const metadata = result.metadata

    // 1. æ„å»º CrawlMetadataRecord
    const crawlRecord: CrawlMetadataRecord = {
      // å…³è”å­—æ®µ
      bookmarkId,
      url,
      finalUrl: result.url,
      domain: extractDomain(result.url),

      // å…ƒæ•°æ®å­—æ®µ
      pageTitle: metadata.title,
      description: metadata.description,
      keywords: metadata.keywords,
      ogTitle: metadata.ogTitle,
      ogDescription: metadata.ogDescription,
      ogImage: metadata.ogImage,
      ogSiteName: metadata.ogSiteName,
      faviconUrl: metadata.iconHref,

      // çŠ¶æ€å­—æ®µ
      source: 'crawler',
      status: 'success',
      httpStatus: result.httpStatus,
      statusGroup: getStatusGroup(result.httpStatus),
      robotsAllowed: result.robotsAllowed,
      crawlSuccess: true,
      crawlCount: 1,
      lastCrawled: Date.now(),
      crawlDuration: result.duration,

      // ç»´æŠ¤å­—æ®µ
      updatedAt: Date.now(),
      version: '2.0'
    }

    // 2. ä¿å­˜åˆ° crawlMetadata è¡¨
    await indexedDBManager.saveCrawlMetadata(crawlRecord)

    // 3. æ›´æ–° bookmarks è¡¨çš„å…³è”å­—æ®µ
    await updateBookmarkMetadataFields(bookmarkId, metadata)

    logger.info('CrawlSaver', `âœ… ä¿å­˜çˆ¬å–ç»“æœ: ${url}`)
  } catch (error) {
    logger.error('CrawlSaver', `âŒ ä¿å­˜å¤±è´¥: ${url}`, error)
    throw error
  }
}

/**
 * ä¿å­˜å¤±è´¥è®°å½•
 */
async function saveCrawlFailure(
  bookmarkId: string,
  url: string,
  result: CrawlResult
): Promise<void> {
  const crawlRecord: CrawlMetadataRecord = {
    bookmarkId,
    url,
    domain: extractDomain(url),

    // å¤±è´¥çŠ¶æ€
    source: 'crawler',
    status: 'failed',
    httpStatus: result.httpStatus || 0,
    statusGroup: result.httpStatus
      ? getStatusGroup(result.httpStatus)
      : 'error',
    robotsAllowed: result.robotsAllowed,
    crawlSuccess: false,
    crawlCount: 1,
    lastCrawled: Date.now(),
    crawlDuration: result.duration,

    // ç»´æŠ¤å­—æ®µ
    updatedAt: Date.now(),
    version: '2.0'
  }

  await indexedDBManager.saveCrawlMetadata(crawlRecord)
}

/**
 * æ›´æ–° bookmarks è¡¨çš„å…ƒæ•°æ®å…³è”å­—æ®µ
 */
async function updateBookmarkMetadataFields(
  bookmarkId: string,
  metadata: PageMetadata
): Promise<void> {
  const bookmark = await indexedDBManager.getBookmarkById(bookmarkId)
  if (!bookmark) {
    logger.warn('CrawlSaver', `ä¹¦ç­¾ä¸å­˜åœ¨: ${bookmarkId}`)
    return
  }

  // æ›´æ–°æ´¾ç”Ÿå­—æ®µï¼ˆç”¨äºæœç´¢å¢å¼ºï¼‰
  const updates: Partial<BookmarkRecord> = {
    // å…³è”å­—æ®µ
    hasMetadata: true,
    metadataUpdatedAt: Date.now(),
    metadataSource: 'crawler',

    // æ´¾ç”Ÿå­—æ®µï¼ˆå°å†™ï¼Œç”¨äºæœç´¢ï¼‰
    metaTitleLower: (metadata.title || '').toLowerCase(),
    metaDescriptionLower: (metadata.description || '').toLowerCase(),
    metaKeywordsTokens: metadata.keywords
      ? metadata.keywords
          .toLowerCase()
          .split(/[,\s]+/)
          .filter(Boolean)
      : [],

    // æœç´¢æƒé‡æå‡
    metaBoost: calculateMetadataBoost(metadata)
  }

  await indexedDBManager.updateBookmark(bookmarkId, updates)
}

/**
 * è®¡ç®—å…ƒæ•°æ®æœç´¢æƒé‡
 */
function calculateMetadataBoost(metadata: PageMetadata): number {
  let boost = 1.0

  // æœ‰æ ‡é¢˜ +0.2
  if (metadata.title) boost += 0.2

  // æœ‰æè¿° +0.2
  if (metadata.description) boost += 0.2

  // æœ‰å…³é”®è¯ +0.1
  if (metadata.keywords) boost += 0.1

  // æœ‰ OG æ•°æ® +0.1
  if (metadata.ogTitle || metadata.ogDescription) boost += 0.1

  return boost
}

/**
 * æå–åŸŸå
 */
function extractDomain(url: string): string {
  try {
    return new URL(url).hostname
  } catch {
    return ''
  }
}

/**
 * è·å– HTTP çŠ¶æ€åˆ†ç»„
 */
function getStatusGroup(status?: number): CrawlMetadataRecord['statusGroup'] {
  if (!status) return 'error'
  if (status >= 200 && status < 300) return '2xx'
  if (status >= 300 && status < 400) return '3xx'
  if (status >= 400 && status < 500) return '4xx'
  if (status >= 500) return '5xx'
  return 'error'
}

// ==================== é«˜çº§ API ====================

/**
 * çˆ¬å–å•ä¸ªä¹¦ç­¾
 */
export async function crawlSingleBookmark(
  bookmark: chrome.bookmarks.BookmarkTreeNode
): Promise<void> {
  if (!bookmark.url) return

  const result = await crawlBookmarkLocally(bookmark.url, {
    respectRobots: true,
    timeout: 10000
  })

  await saveCrawlResult(bookmark.id, bookmark.url, result)
}

/**
 * æ‰¹é‡çˆ¬å–ä¹¦ç­¾ï¼ˆä½¿ç”¨ä»»åŠ¡è°ƒåº¦å™¨ï¼‰
 */
export async function crawlMultipleBookmarks(
  bookmarks: chrome.bookmarks.BookmarkTreeNode[],
  options?: CrawlOptions
): Promise<void> {
  await crawlTaskScheduler.scheduleBookmarksCrawl(bookmarks, {
    ...options,
    onTaskComplete: async task => {
      if (task.result) {
        await saveCrawlResult(task.bookmarkId, task.url, task.result)
      }
    }
  })
}

/**
 * è·å–ä¹¦ç­¾çš„çˆ¬å–å…ƒæ•°æ®
 */
export async function getBookmarkMetadata(
  bookmarkId: string
): Promise<CrawlMetadataRecord | null> {
  return await indexedDBManager.getCrawlMetadata(bookmarkId)
}

/**
 * æ£€æŸ¥ä¹¦ç­¾æ˜¯å¦éœ€è¦çˆ¬å–
 */
export async function needsCrawl(bookmarkId: string): Promise<boolean> {
  const metadata = await indexedDBManager.getCrawlMetadata(bookmarkId)

  // æ²¡æœ‰å…ƒæ•°æ®ï¼Œéœ€è¦çˆ¬å–
  if (!metadata) return true

  // çˆ¬å–å¤±è´¥ï¼Œéœ€è¦é‡è¯•
  if (!metadata.crawlSuccess) {
    const daysSinceLastCrawl =
      (Date.now() - (metadata.lastCrawled || 0)) / (1000 * 60 * 60 * 24)
    return daysSinceLastCrawl > 1 // å¤±è´¥1å¤©åé‡è¯•
  }

  // æˆåŠŸä½†è¿‡æœŸï¼ˆ30å¤©ï¼‰ï¼Œéœ€è¦åˆ·æ–°
  const daysSinceUpdate =
    (Date.now() - metadata.updatedAt) / (1000 * 60 * 60 * 24)
  return daysSinceUpdate > 30
}

/**
 * è·å–éœ€è¦çˆ¬å–çš„ä¹¦ç­¾åˆ—è¡¨
 */
export async function getBookmarksNeedingCrawl(): Promise<
  chrome.bookmarks.BookmarkTreeNode[]
> {
  const allBookmarks = await chrome.bookmarks.getTree()
  const flatBookmarks = flattenBookmarkTree(allBookmarks)

  const needsCrawlList: chrome.bookmarks.BookmarkTreeNode[] = []

  for (const bookmark of flatBookmarks) {
    if (!bookmark.url || bookmark.url.startsWith('chrome://')) continue

    const needs = await needsCrawl(bookmark.id)
    if (needs) {
      needsCrawlList.push(bookmark)
    }
  }

  return needsCrawlList
}

/**
 * æ‰å¹³åŒ–ä¹¦ç­¾æ ‘
 */
function flattenBookmarkTree(
  nodes: chrome.bookmarks.BookmarkTreeNode[]
): chrome.bookmarks.BookmarkTreeNode[] {
  const result: chrome.bookmarks.BookmarkTreeNode[] = []

  function traverse(node: chrome.bookmarks.BookmarkTreeNode) {
    if (node.url) {
      result.push(node)
    }

    if (node.children) {
      node.children.forEach(traverse)
    }
  }

  nodes.forEach(traverse)
  return result
}
```

---

## ğŸ”„ ä¿®æ”¹ç°æœ‰æ–‡ä»¶

### ä¿®æ”¹1: `lightweight-bookmark-enhancer.ts`

**å®Œæ•´é‡æ„ç‰ˆæœ¬**ï¼ˆåªä¿ç•™å¿…è¦åŠŸèƒ½ï¼‰ï¼š

```typescript
/**
 * è½»é‡çº§ä¹¦ç­¾å¢å¼ºå™¨ï¼ˆé‡æ„ç‰ˆï¼‰
 *
 * èŒè´£ï¼š
 * - æä¾›ä¾¿æ·çš„çˆ¬å– API
 * - å§”æ‰˜ç»™æ–°çš„æœ¬åœ°çˆ¬è™«æœåŠ¡
 * - ä¿æŒå‘åå…¼å®¹
 *
 * âš ï¸ å·²åºŸå¼ƒç‹¬ç«‹ IndexedDBï¼Œç»Ÿä¸€ä½¿ç”¨ AcuityBookmarksDB
 */

import {
  crawlSingleBookmark,
  crawlMultipleBookmarks
} from './local-bookmark-crawler'
import { logger } from '@/infrastructure/logging/logger'

/**
 * @deprecated ä½¿ç”¨ CrawlMetadataRecord æ›¿ä»£
 */
export interface LightweightBookmarkMetadata {
  // ä¿ç•™ç±»å‹å®šä¹‰ç”¨äºå‘åå…¼å®¹
  id: string
  url: string
  title: string
  extractedTitle: string
  description: string
  keywords: string
  ogTitle: string
  ogDescription: string
  ogImage: string
  ogSiteName: string
  // ... å…¶ä»–å­—æ®µ
}

/**
 * è½»é‡çº§ä¹¦ç­¾å¢å¼ºå™¨ï¼ˆç®€åŒ–ç‰ˆï¼‰
 */
export class LightweightBookmarkEnhancer {
  /**
   * å¢å¼ºå•ä¸ªä¹¦ç­¾
   * @deprecated ä½¿ç”¨ crawlSingleBookmark æ›¿ä»£
   */
  async enhanceBookmark(
    bookmark: chrome.bookmarks.BookmarkTreeNode
  ): Promise<void> {
    logger.warn(
      'LightweightEnhancer',
      'âš ï¸ enhanceBookmark å·²åºŸå¼ƒï¼Œä½¿ç”¨ crawlSingleBookmark'
    )
    await crawlSingleBookmark(bookmark)
  }

  /**
   * æ‰¹é‡å¢å¼ºä¹¦ç­¾
   * @deprecated ä½¿ç”¨ crawlMultipleBookmarks æ›¿ä»£
   */
  async enhanceBookmarks(
    bookmarks: chrome.bookmarks.BookmarkTreeNode[]
  ): Promise<void> {
    logger.warn(
      'LightweightEnhancer',
      'âš ï¸ enhanceBookmarks å·²åºŸå¼ƒï¼Œä½¿ç”¨ crawlMultipleBookmarks'
    )
    await crawlMultipleBookmarks(bookmarks)
  }
}

// å¯¼å‡ºå•ä¾‹ï¼ˆå‘åå…¼å®¹ï¼‰
export const lightweightBookmarkEnhancer = new LightweightBookmarkEnhancer()
```

### ä¿®æ”¹2: æ·»åŠ  IndexedDB Manager æ–¹æ³•

åœ¨ `utils-legacy/indexeddb-manager.ts` ä¸­æ·»åŠ ï¼š

```typescript
/**
 * ä¿å­˜çˆ¬å–å…ƒæ•°æ®
 */
async saveCrawlMetadata(record: CrawlMetadataRecord): Promise<void> {
  if (!this.db) {
    throw new Error('Database not initialized')
  }

  return new Promise((resolve, reject) => {
    const transaction = this.db!.transaction([DB_CONFIG.STORES.CRAWL_METADATA], 'readwrite')
    const store = transaction.objectStore(DB_CONFIG.STORES.CRAWL_METADATA)
    const request = store.put(record)

    request.onsuccess = () => resolve()
    request.onerror = () => reject(request.error)
  })
}

/**
 * è·å–çˆ¬å–å…ƒæ•°æ®
 */
async getCrawlMetadata(bookmarkId: string): Promise<CrawlMetadataRecord | null> {
  if (!this.db) {
    throw new Error('Database not initialized')
  }

  return new Promise((resolve, reject) => {
    const transaction = this.db!.transaction([DB_CONFIG.STORES.CRAWL_METADATA], 'readonly')
    const store = transaction.objectStore(DB_CONFIG.STORES.CRAWL_METADATA)
    const request = store.get(bookmarkId)

    request.onsuccess = () => resolve(request.result || null)
    request.onerror = () => reject(request.error)
  })
}

/**
 * æ‰¹é‡è·å–çˆ¬å–å…ƒæ•°æ®
 */
async getBatchCrawlMetadata(bookmarkIds: string[]): Promise<Map<string, CrawlMetadataRecord>> {
  const result = new Map<string, CrawlMetadataRecord>()

  for (const id of bookmarkIds) {
    const metadata = await this.getCrawlMetadata(id)
    if (metadata) {
      result.set(id, metadata)
    }
  }

  return result
}

/**
 * åˆ é™¤çˆ¬å–å…ƒæ•°æ®
 */
async deleteCrawlMetadata(bookmarkId: string): Promise<void> {
  if (!this.db) {
    throw new Error('Database not initialized')
  }

  return new Promise((resolve, reject) => {
    const transaction = this.db!.transaction([DB_CONFIG.STORES.CRAWL_METADATA], 'readwrite')
    const store = transaction.objectStore(DB_CONFIG.STORES.CRAWL_METADATA)
    const request = store.delete(bookmarkId)

    request.onsuccess = () => resolve()
    request.onerror = () => reject(request.error)
  })
}
```

---

## ğŸ“‹ æ¸…ç†æ£€æŸ¥æ¸…å•

### å¿…é¡»åˆ é™¤çš„æ–‡ä»¶

- [ ] `frontend/src/services/serverless-crawler-client.ts`

### å¿…é¡»ä¿®æ”¹çš„æ–‡ä»¶

- [ ] `frontend/src/services/lightweight-bookmark-enhancer.ts`
  - [ ] åˆ é™¤ `serverlessCrawlerClient` å¯¼å…¥
  - [ ] åˆ é™¤ç‹¬ç«‹ IndexedDB ä»£ç 
  - [ ] ä½¿ç”¨æ–°çš„ `local-bookmark-crawler`

- [ ] `frontend/src/services/crawl-task-scheduler.ts`
  - [ ] é›†æˆæ•°æ®ä¿å­˜é€»è¾‘

- [ ] `frontend/src/utils-legacy/indexeddb-manager.ts`
  - [ ] æ·»åŠ  `saveCrawlMetadata` æ–¹æ³•
  - [ ] æ·»åŠ  `getCrawlMetadata` æ–¹æ³•

### éœ€è¦åˆ›å»ºçš„æ–‡ä»¶

- [ ] `frontend/src/services/local-bookmark-crawler.ts`ï¼ˆæ–°æ–‡ä»¶ï¼Œç»Ÿä¸€å…¥å£ï¼‰

### éœ€è¦æ£€æŸ¥çš„æ–‡ä»¶

- [ ] `frontend/src/services/smart-recommendation-engine.ts`
  - [ ] æ£€æŸ¥æ˜¯å¦å¼•ç”¨äº† `serverlessCrawlerClient`
  - [ ] æ£€æŸ¥æ˜¯å¦å¼•ç”¨äº†æ—§çš„ `lightweightBookmarkEnhancer`

- [ ] `frontend/background.js`
  - [ ] æ›´æ–°å¯¼å…¥è·¯å¾„

### ç¯å¢ƒå˜é‡

- [ ] `.env` æ–‡ä»¶
  ```bash
  # å¼ºåˆ¶æœ¬åœ°æ¨¡å¼
  VITE_CRAWLER_MODE=local
  ```

---

## ğŸ§ª æµ‹è¯•éªŒè¯

### æµ‹è¯•1: æ•°æ®ä¿å­˜éªŒè¯

```typescript
// æµ‹è¯•ä¿å­˜åˆ°æ­£ç¡®çš„è¡¨
async function testDataSaving() {
  const testBookmark = {
    id: 'test_123',
    title: 'Test',
    url: 'https://example.com'
  }

  // 1. çˆ¬å–
  await crawlSingleBookmark(testBookmark)

  // 2. éªŒè¯ crawlMetadata è¡¨
  const crawlData = await indexedDBManager.getCrawlMetadata('test_123')
  console.assert(crawlData !== null, 'crawlMetadata åº”è¯¥å­˜åœ¨')
  console.assert(crawlData.bookmarkId === 'test_123', 'bookmarkId åº”è¯¥åŒ¹é…')

  // 3. éªŒè¯ bookmarks è¡¨
  const bookmark = await indexedDBManager.getBookmarkById('test_123')
  console.assert(bookmark.hasMetadata === true, 'hasMetadata åº”è¯¥ä¸º true')
  console.assert(bookmark.metadataUpdatedAt > 0, 'metadataUpdatedAt åº”è¯¥è¢«è®¾ç½®')

  console.log('âœ… æ•°æ®ä¿å­˜éªŒè¯é€šè¿‡')
}
```

### æµ‹è¯•2: å…³è”æŸ¥è¯¢éªŒè¯

```typescript
// æµ‹è¯•ä¹¦ç­¾ä¸å…ƒæ•°æ®çš„å…³è”
async function testDataAssociation() {
  const bookmark = await indexedDBManager.getBookmarkById('test_123')

  if (bookmark.hasMetadata) {
    const metadata = await indexedDBManager.getCrawlMetadata(bookmark.id)
    console.assert(metadata !== null, 'å…³è”çš„å…ƒæ•°æ®åº”è¯¥å­˜åœ¨')
    console.log('âœ… å…³è”æŸ¥è¯¢éªŒè¯é€šè¿‡')
  }
}
```

### æµ‹è¯•3: æœç´¢å¢å¼ºéªŒè¯

```typescript
// æµ‹è¯•å…ƒæ•°æ®æ˜¯å¦å¢å¼ºäº†æœç´¢
async function testSearchEnhancement() {
  // æœç´¢æ—¶åº”è¯¥èƒ½åŒ¹é…å…ƒæ•°æ®ä¸­çš„å†…å®¹
  const results = await searchBookmarks('å…³é”®è¯æ¥è‡ªå…ƒæ•°æ®')

  console.assert(results.length > 0, 'åº”è¯¥èƒ½æœç´¢åˆ°å…ƒæ•°æ®ä¸­çš„å†…å®¹')
  console.log('âœ… æœç´¢å¢å¼ºéªŒè¯é€šè¿‡')
}
```

---

## ğŸ“Š æ•°æ®è¿ç§»

### è¿ç§»æ—§æ•°æ®ï¼ˆå¯é€‰ï¼‰

å¦‚æœéœ€è¦è¿ç§» `AcuityBookmarks_LightweightCache` ä¸­çš„æ•°æ®ï¼š

```typescript
async function migrateOldCrawlData() {
  // 1. æ‰“å¼€æ—§æ•°æ®åº“
  const oldDB = await new Promise<IDBDatabase>((resolve, reject) => {
    const request = indexedDB.open('AcuityBookmarks_LightweightCache', 1)
    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })

  // 2. è¯»å–æ‰€æœ‰æ•°æ®
  const oldData: any[] = await new Promise((resolve, reject) => {
    const transaction = oldDB.transaction(['bookmark_metadata'], 'readonly')
    const store = transaction.objectStore('bookmark_metadata')
    const request = store.getAll()

    request.onsuccess = () => resolve(request.result)
    request.onerror = () => reject(request.error)
  })

  // 3. è½¬æ¢å¹¶ä¿å­˜åˆ°æ–°æ•°æ®åº“
  for (const old of oldData) {
    const newRecord: CrawlMetadataRecord = {
      bookmarkId: old.id,
      url: old.url,
      pageTitle: old.extractedTitle,
      description: old.description,
      keywords: old.keywords,
      ogTitle: old.ogTitle,
      ogDescription: old.ogDescription,
      ogImage: old.ogImage,
      ogSiteName: old.ogSiteName,
      source: 'crawler',
      status: old.crawlSuccess ? 'success' : 'failed',
      lastCrawled: old.lastCrawled,
      updatedAt: old.lastCrawled || Date.now(),
      version: '2.0'
    }

    await indexedDBManager.saveCrawlMetadata(newRecord)
  }

  // 4. åˆ é™¤æ—§æ•°æ®åº“
  oldDB.close()
  await indexedDB.deleteDatabase('AcuityBookmarks_LightweightCache')

  console.log(`âœ… è¿ç§»å®Œæˆ: ${oldData.length} æ¡è®°å½•`)
}
```

---

## ğŸ¯ å®æ–½æ­¥éª¤

### ç¬¬1å¤©ï¼šæ¸…ç†ä»£ç 

1. âœ… åˆ é™¤ `serverless-crawler-client.ts`
2. âœ… åˆ›å»º `local-bookmark-crawler.ts`
3. âœ… ä¿®æ”¹ `lightweight-bookmark-enhancer.ts`
4. âœ… æ›´æ–° IndexedDB Manager

### ç¬¬2å¤©ï¼šæµ‹è¯•éªŒè¯

1. âœ… å•å…ƒæµ‹è¯•
2. âœ… é›†æˆæµ‹è¯•
3. âœ… æ•°æ®ä¿å­˜éªŒè¯
4. âœ… å…³è”æŸ¥è¯¢éªŒè¯

### ç¬¬3å¤©ï¼šæ•°æ®è¿ç§»

1. âœ… è¿ç§»è„šæœ¬ï¼ˆå¦‚éœ€è¦ï¼‰
2. âœ… æ¸…ç†æ—§æ•°æ®åº“
3. âœ… æ€§èƒ½æµ‹è¯•

---

## âœ… å®Œæˆæ ‡å¿—

- [ ] æ‰€æœ‰ `serverless-crawler-client` å¼•ç”¨å·²æ¸…ç†
- [ ] æ•°æ®ä¿å­˜åˆ° `crawlMetadata` è¡¨
- [ ] `bookmarks` è¡¨çš„ `hasMetadata` å­—æ®µæ­£ç¡®æ›´æ–°
- [ ] æœç´¢èƒ½åŒ¹é…å…ƒæ•°æ®å†…å®¹
- [ ] æ²¡æœ‰ç‹¬ç«‹çš„ `AcuityBookmarks_LightweightCache` æ•°æ®åº“
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] 100% æœ¬åœ°æ‰§è¡Œï¼Œæ— æ•°æ®ä¸Šä¼ 

---

**ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-10-12  
**çŠ¶æ€**: âœ… å¾…å®æ–½
