# 🏗️ AcuityBookmarks 单向数据流架构

## 核心原则

> **数据流永远是单向的：Chrome API → IndexedDB → UI**
>
> 不允许任何逆向数据流，保证数据一致性和可预测性。

---

## 📊 完整数据流图

```
┌─────────────────────────────────────────────────────────────────┐
│                     Chrome Bookmarks API                        │
│                    (唯一的真实数据源)                             │
└──────────────────┬──────────────────────────────────────────────┘
                   │
                   │ chrome.bookmarks.onCreated
                   │ chrome.bookmarks.onChanged
                   │ chrome.bookmarks.onMoved
                   │ chrome.bookmarks.onRemoved
                   │
                   ↓
┌─────────────────────────────────────────────────────────────────┐
│             Background/Service Worker (中心化监听)               │
│  • background.js                                                │
│  • setupBookmarkChangeListeners()                               │
│  • syncAndBroadcast(eventType, id)                              │
└──────────────────┬──────────────────────────────────────────────┘
                   │
                   │ (1) 完整同步
                   ↓
┌─────────────────────────────────────────────────────────────────┐
│                    IndexedDB (中心化存储)                         │
│  • bookmarkSyncService.syncAllBookmarks()                       │
│  • flattenBookmarkTree() → 生成 pathIds                         │
│  • convertChromeNodeToRecord() → 完整元数据                      │
│  • indexedDBManager.updateBookmark()                            │
└──────────────────┬──────────────────────────────────────────────┘
                   │
                   │ (2) 广播更新消息
                   ↓
┌─────────────────────────────────────────────────────────────────┐
│                  chrome.runtime.sendMessage({                   │
│                    type: 'BOOKMARKS_DB_SYNCED',                 │
│                    eventType: 'created|changed|moved|removed',  │
│                    bookmarkId: id,                              │
│                    timestamp: Date.now()                        │
│                  })                                             │
└──────────────────┬──────────────────────────────────────────────┘
                   │
                   │ (3) 所有页面接收
                   ↓
┌─────────────────────────────────────────────────────────────────┐
│                     应用页面 (UI 层)                              │
│  ┌──────────────┬──────────────┬──────────────┐                │
│  │ Management   │  Side Panel  │   Popup      │                │
│  │  页面        │    页面      │    页面      │                │
│  └──────────────┴──────────────┴──────────────┘                │
│                                                                 │
│  • modern-bookmark-service.ts 监听消息                           │
│  • dispatchCoalescedEvent(AB_EVENTS.BOOKMARKS_DB_SYNCED)       │
│  • Management.vue: handleDbSynced() → refreshCache()           │
│  • 从 IndexedDB 读取最新数据                                     │
│  • 更新 UI                                                      │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🔑 关键实现

### 1. Background 中心化监听（`background.js`）

```javascript
/**
 * 🔄 设置书签变化监听器
 * 架构原则：单向数据流
 * Chrome API → IndexedDB → 广播消息 → UI 更新
 */
function setupBookmarkChangeListeners() {
  // 监听书签创建
  chrome.bookmarks.onCreated.addListener(async (id, bookmark) => {
    console.log('📝 [Background] 书签已创建:', bookmark.title)
    await syncAndBroadcast('created', id)
  })

  // 监听其他事件...
  chrome.bookmarks.onChanged.addListener(...)
  chrome.bookmarks.onMoved.addListener(...)
  chrome.bookmarks.onRemoved.addListener(...)
}

/**
 * 🔄 同步到 IndexedDB 并广播更新消息
 */
async function syncAndBroadcast(eventType, id) {
  // 1. 完整同步到 IndexedDB（确保 pathIds 等字段正确）
  await bookmarkSyncService.syncAllBookmarks()

  // 2. 广播消息到所有页面
  chrome.runtime.sendMessage({
    type: 'BOOKMARKS_DB_SYNCED',
    eventType: eventType,
    bookmarkId: id,
    timestamp: Date.now()
  })
}
```

### 2. 前端页面监听广播（`modern-bookmark-service.ts`）

```javascript
chrome.runtime.onMessage.addListener(message => {
  if (message.type === 'BOOKMARKS_DB_SYNCED') {
    // 合并与节流：150ms 内仅派发一次
    dispatchCoalescedEvent(
      AB_EVENTS.BOOKMARKS_DB_SYNCED,
      { timestamp: message.timestamp || Date.now() },
      150
    )
  }
})
```

### 3. Management 页面响应（`Management.vue`）

```javascript
// 监听 IndexedDB 同步完成事件
const handleDbSynced = async () => {
  console.log('[Management] 📡 收到 IndexedDB 同步完成事件')

  // 从 IndexedDB 刷新数据
  await refreshCache()

  // 更新 UI
  isPageLoading.value = false
}

// 注册监听器
window.addEventListener(AB_EVENTS.BOOKMARKS_DB_SYNCED, handleDbSynced)
```

---

## 🎯 典型场景

### 场景 1：用户在 Management 页面生成书签

```
步骤 1: Management 页面
  ↓ chrome.bookmarks.create({ ... })

步骤 2: Chrome API
  ↓ 触发 chrome.bookmarks.onCreated 事件

步骤 3: Background/Service Worker
  ↓ 监听到事件
  ↓ await bookmarkSyncService.syncAllBookmarks()
  ↓ (完整同步，生成 pathIds)

步骤 4: IndexedDB
  ↓ 数据已更新

步骤 5: Background
  ↓ chrome.runtime.sendMessage({ type: 'BOOKMARKS_DB_SYNCED' })

步骤 6: Management 页面
  ↓ 接收到消息
  ↓ handleDbSynced()
  ↓ refreshCache() - 从 IndexedDB 读取
  ↓ 更新 UI
```

### 场景 2：外部更改书签（浏览器书签管理器）

```
步骤 1: 浏览器书签管理器
  ↓ 用户修改/删除书签

步骤 2: Chrome API
  ↓ 触发 chrome.bookmarks.onChanged 事件

步骤 3-6: 同场景 1
  ↓ Background 监听 → 同步 IndexedDB → 广播 → UI 更新
```

### 场景 3：Management 页面编辑书签

```
步骤 1: Management 页面
  ↓ chrome.bookmarks.update(id, { title: '新标题' })

步骤 2: Chrome API
  ↓ 触发 chrome.bookmarks.onChanged 事件

步骤 3-6: 同场景 1
  ↓ Background 监听 → 同步 IndexedDB → 广播 → UI 更新
```

---

## ✅ 架构优势

### 1. 数据一致性

- **单一数据源**：IndexedDB 是所有页面的数据源
- **自动同步**：任何书签变化都会自动同步到 IndexedDB
- **无冲突**：不存在数据不一致的情况

### 2. 可预测性

- **单向流动**：数据流向清晰，易于理解和调试
- **事件驱动**：通过事件机制解耦，各模块职责明确

### 3. 可维护性

- **中心化管理**：Background 统一处理同步逻辑
- **易于扩展**：新增页面只需监听 `BOOKMARKS_DB_SYNCED` 事件
- **调试友好**：完整的日志记录，便于追踪数据流

### 4. 性能优化

- **批量同步**：Background 控制同步频率，避免重复
- **节流合并**：150ms 内的多次变化合并为一次更新
- **按需刷新**：页面只在需要时从 IndexedDB 读取

---

## 🚫 禁止的反模式

### ❌ 反模式 1：前端直接同步 IndexedDB

```javascript
// ❌ 错误：前端页面直接调用同步
async function onBookmarkCreate() {
  await chrome.bookmarks.create({ ... })
  await bookmarkSyncService.syncAllBookmarks()  // ❌ 不要这样做！
  refreshUI()
}
```

**为什么错误**：

- 违反单向数据流原则
- 可能导致多个页面重复同步
- 无法保证其他页面收到更新

### ❌ 反模式 2：UI 直接读取 Chrome API

```javascript
// ❌ 错误：UI 直接读取 Chrome API
async function loadBookmarks() {
  const tree = await chrome.bookmarks.getTree() // ❌ 不要这样做！
  displayTree(tree)
}
```

**为什么错误**：

- 绕过 IndexedDB，导致数据不一致
- 缺少 pathIds 等预处理字段
- 无法利用 IndexedDB 的缓存和索引

### ❌ 反模式 3：页面之间直接通信

```javascript
// ❌ 错误：页面之间直接传递数据
chrome.runtime.sendMessage({
  type: 'UPDATE_OTHER_PAGE',
  data: bookmarks // ❌ 不要这样做！
})
```

**为什么错误**：

- 违反单一数据源原则
- 可能导致数据版本冲突
- 难以维护和调试

---

## ✅ 正确的做法

### ✅ 正确 1：通过 Background 同步

```javascript
// ✅ 正确：让 Background 监听事件并同步
async function createBookmark(data) {
  // 1. 调用 Chrome API
  await chrome.bookmarks.create(data)

  // 2. Background 会自动：
  //    - 监听 onCreated 事件
  //    - 同步到 IndexedDB
  //    - 广播 BOOKMARKS_DB_SYNCED

  // 3. 当前页面会自动：
  //    - 接收广播消息
  //    - 从 IndexedDB 刷新数据
  //    - 更新 UI
}
```

### ✅ 正确 2：从 IndexedDB 读取

```javascript
// ✅ 正确：始终从 IndexedDB 读取
async function loadBookmarks() {
  const bookmarks = await indexedDBManager.getAllBookmarks()
  // bookmarks 包含完整的 pathIds、depth 等字段
  displayTree(buildTreeFromFlat(bookmarks))
}
```

### ✅ 正确 3：监听统一事件

```javascript
// ✅ 正确：监听 Background 的广播事件
window.addEventListener(AB_EVENTS.BOOKMARKS_DB_SYNCED, async () => {
  // IndexedDB 已更新，刷新 UI
  await refreshFromIndexedDB()
})
```

---

## 📝 关键文件清单

### Background 层（中心化同步）

- **`frontend/background.js`**
  - `setupBookmarkChangeListeners()` - 监听 Chrome 书签事件
  - `syncAndBroadcast()` - 同步到 IndexedDB 并广播

### 服务层（数据处理）

- **`frontend/src/services/bookmark-sync-service.ts`**
  - `syncAllBookmarks()` - 完整同步
  - `flattenBookmarkTree()` - 扁平化树
  - `convertChromeNodeToRecord()` - 生成 pathIds 等字段

### IndexedDB 层（持久化存储）

- **`frontend/src/infrastructure/indexeddb/manager.ts`**
  - `updateBookmark()` - 更新单个书签
  - `getAllBookmarks()` - 获取所有书签
  - `getChildrenByParentId()` - 获取子书签

### 前端页面层（UI 更新）

- **`frontend/src/services/modern-bookmark-service.ts`**
  - 监听 `chrome.runtime.onMessage`
  - 派发 `AB_EVENTS.BOOKMARKS_DB_SYNCED` 事件

- **`frontend/src/management/Management.vue`**
  - 监听 `AB_EVENTS.BOOKMARKS_DB_SYNCED`
  - `handleDbSynced()` - 响应同步完成
  - `refreshCache()` - 从 IndexedDB 刷新

---

## 🔧 调试指南

### 查看数据流日志

1. **Background 日志**（Service Worker 控制台）

   ```
   📝 [Background] 书签已创建: Sample 1 · Bravo
   🔄 [Background] 同步到 IndexedDB: created 123
   ✅ [Background] 同步完成并已广播: created
   ```

2. **IndexedDB 同步日志**

   ```
   BookmarkSync 🚀 开始同步书签...
   BookmarkSync 📚 获取到书签树，根节点数: 1
   BookmarkSync 📊 扁平化后共 46745 条记录
   BookmarkSync ✅ 同步完成！共写入 46745 条书签
   ```

3. **前端页面日志**（Management 页面控制台）
   ```
   📡 [前端] 已合并派发 BOOKMARKS_DB_SYNCED 事件
   [Management] 📡 收到 IndexedDB 同步完成事件
   [Management] 🔄 开始刷新缓存...
   ```

### 常见问题排查

**问题 1：生成书签后 UI 不更新**

检查：

1. Background 是否监听到事件？→ 查看 Service Worker 控制台
2. IndexedDB 是否已同步？→ 查看 `BookmarkSync` 日志
3. 页面是否收到广播？→ 查看 `BOOKMARKS_DB_SYNCED` 日志

**问题 2：Hover 高亮不工作**

检查：

1. 书签是否有 `pathIds` 字段？→ 打印 `node.pathIds`
2. IndexedDB 是否完整同步？→ 确认走了 `syncAllBookmarks()`
3. 是否通过 Background 同步？→ 不要前端直接调用

**问题 3：数据不一致**

检查：

1. 是否绕过 IndexedDB？→ 确保不直接读 Chrome API
2. 是否有逆向数据流？→ 确保只有 Background 写 IndexedDB
3. 是否有重复同步？→ 检查是否多处调用 `syncAllBookmarks()`

---

## 🎯 总结

### 核心原则（再次强调）

1. **Chrome API 是唯一的真实数据源**
2. **Background 是唯一的同步入口**
3. **IndexedDB 是唯一的数据源**
4. **所有页面只从 IndexedDB 读取**
5. **通过事件广播更新 UI**

### 数据流公式

```
Chrome API → Background → IndexedDB → 广播 → UI
```

**永远不要逆向！**

---

**文档版本**: v1.0  
**最后更新**: 2025-10-14  
**维护者**: AcuityBookmarks Team
