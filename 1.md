### 1. IndexedDB äº‹åŠ¡ç®¡ç†ç°çŠ¶

é¡¹ç›®ä¸­æœ‰ä¸¤ä¸ª IndexedDB ç®¡ç†å™¨å®ç°ï¼š<cite/>

**Service Worker ç«¯** (`background.js`): ä½¿ç”¨ç¡¬ç¼–ç çš„ 2000 æ¡æ‰¹æ¬¡å¤§å°ï¼Œæ¯æ‰¹æ¬¡é—´é€šè¿‡ `setTimeout(resolve, 0)` è®©å‡ºæ§åˆ¶æƒ [1](#2-0)

**å‰ç«¯** (`frontend/src/utils/indexeddb-manager.ts`): åœ¨å•ä¸ªäº‹åŠ¡ä¸­å¤„ç†æ‰€æœ‰æ•°æ®ï¼Œæ²¡æœ‰åˆ†æ‰¹ [2](#2-1)

### 2. æ•°æ®åºåˆ—åŒ–ç°çŠ¶

Chrome API è¿”å›çš„ä¹¦ç­¾æ•°æ®éœ€è¦ç»è¿‡é¢„å¤„ç†æ‰èƒ½å­˜å…¥ IndexedDBï¼ŒåŒ…æ‹¬ç”Ÿæˆ `titleLower`ã€`tags`ã€`keywords` ç­‰æ´¾ç”Ÿå­—æ®µ [3](#2-2)

## ä¼˜åŒ–æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šäº‹åŠ¡ç®¡ç†ä¼˜åŒ–ï¼ˆæ¨èç«‹å³å®æ–½ï¼‰

#### 1.1 åŠ¨æ€æ‰¹æ¬¡å¤§å°

æ ¹æ®è®¾å¤‡æ€§èƒ½å’Œæ•°æ®é‡åŠ¨æ€è°ƒæ•´æ‰¹æ¬¡å¤§å°ï¼š<cite/>

```typescript
// åœ¨ IndexedDBManager ä¸­æ·»åŠ 
private calculateOptimalBatchSize(totalRecords: number): number {
  // åŸºäºå¯ç”¨å†…å­˜ä¼°ç®—
  const memoryGB = (navigator as any).deviceMemory || 4
  const baseBatchSize = memoryGB >= 8 ? 5000 : 2000

  // å°æ•°æ®é›†ä¸åˆ†æ‰¹
  if (totalRecords < 1000) return totalRecords

  // å¤§æ•°æ®é›†ä½¿ç”¨æ›´å°æ‰¹æ¬¡é¿å…é˜»å¡
  if (totalRecords > 100000) return Math.min(baseBatchSize, 1000)

  return baseBatchSize
}
```

#### 1.2 äº‹åŠ¡æ± åŒ–ï¼ˆTransaction Poolingï¼‰

å½“å‰æ¯æ‰¹æ¬¡éƒ½åˆ›å»ºæ–°äº‹åŠ¡ï¼Œå¼€é”€å¤§ã€‚<cite/>å¯ä»¥å¤ç”¨äº‹åŠ¡è¿æ¥ï¼š<cite/>

```typescript
// å‚è€ƒé¡¹ç›®å·²æœ‰çš„ connection-pool.ts æ¨¡å¼
import { idbConnectionPool } from '@/infrastructure/indexeddb/connection-pool'

async insertBookmarksOptimized(bookmarks: BookmarkRecord[]): Promise<void> {
  const batchSize = this.calculateOptimalBatchSize(bookmarks.length)

  // ä½¿ç”¨ withTransaction å¤ç”¨è¿æ¥
  const { withTransaction } = await import(
    '@/infrastructure/indexeddb/transaction-manager'
  )

  for (let i = 0; i < bookmarks.length; i += batchSize) {
    const chunk = bookmarks.slice(i, i + batchSize)

    await withTransaction(
      [DB_CONFIG.STORES.BOOKMARKS],
      'readwrite',
      async (tx) => {
        const store = tx.objectStore(DB_CONFIG.STORES.BOOKMARKS)

        // æ‰¹é‡æäº¤ï¼Œå•ä¸ªäº‹åŠ¡å†…
        const promises = chunk.map(bookmark =>
          new Promise<void>((resolve, reject) => {
            const req = store.put(bookmark)
            req.onsuccess = () => resolve()
            req.onerror = () => reject(req.error)
          })
        )

        await Promise.all(promises)
      },
      { retries: 2, retryDelayMs: 50 }
    )

    // æ‰¹æ¬¡é—´è®©å‡ºæ§åˆ¶æƒ
    if (i + batchSize < bookmarks.length) {
      await new Promise(r => requestIdleCallback(r as any, { timeout: 100 }))
    }
  }
}
```

é¡¹ç›®å·²æœ‰ `transaction-manager.ts` å’Œ `connection-pool.ts` åŸºç¡€è®¾æ–½ [4](#2-3) ï¼Œå¯ä»¥ç›´æ¥åˆ©ç”¨ã€‚<cite/>

#### 1.3 å¢é‡æ›´æ–°æ›¿ä»£å…¨é‡åˆ·æ–°

å½“å‰ `loadBookmarkData()` æ¯æ¬¡éƒ½æ¸…ç©ºå†æ’å…¥ [5](#2-4) ï¼Œå¯ä»¥æ”¹ä¸ºå¢é‡æ›´æ–°ï¼š<cite/>

```typescript
async syncBookmarksIncremental(): Promise<void> {
  const chromeBookmarks = await this.preprocessor.processBookmarks()
  const cachedBookmarks = await this.dbManager.getAllBookmarks()

  // æ„å»º ID æ˜ å°„
  const cachedMap = new Map(cachedBookmarks.map(b => [b.id, b]))
  const chromeMap = new Map(chromeBookmarks.bookmarks.map(b => [b.id, b]))

  // è®¡ç®—å·®å¼‚
  const toInsert = chromeBookmarks.bookmarks.filter(b => !cachedMap.has(b.id))
  const toUpdate = chromeBookmarks.bookmarks.filter(b => {
    const cached = cachedMap.get(b.id)
    return cached && (cached.title !== b.title || cached.url !== b.url)
  })
  const toDelete = cachedBookmarks.filter(b => !chromeMap.has(b.id))

  // æ‰¹é‡æ‰§è¡Œ
  if (toDelete.length > 0) {
    await this.dbManager.deleteBookmarksBatch(toDelete.map(b => b.id))
  }
  if (toInsert.length > 0) {
    await this.dbManager.insertBookmarks(toInsert)
  }
  if (toUpdate.length > 0) {
    await this.dbManager.updateBookmarksBatch(toUpdate)
  }
}
```

### æ–¹æ¡ˆäºŒï¼šæ•°æ®åºåˆ—åŒ–ä¼˜åŒ–

#### 2.1 Web Worker é¢„å¤„ç†

å°†æ•°æ®è½¬æ¢ç§»åˆ° Web Workerï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹ï¼š<cite/>

```typescript
// workers/bookmark-preprocessor.worker.ts
self.onmessage = async e => {
  const { type, data } = e.data

  if (type === 'PREPROCESS_BOOKMARKS') {
    const processed = data.map(bookmark => ({
      ...bookmark,
      titleLower: bookmark.title?.toLowerCase() || '',
      urlLower: bookmark.url?.toLowerCase() || '',
      domain: extractDomain(bookmark.url),
      tags: normalizeTags(bookmark.tags),
      keywords: extractKeywords(bookmark.title, bookmark.url)
    }))

    self.postMessage({ type: 'PROCESSED', data: processed })
  }
}

// åœ¨ Service Worker ä¸­ä½¿ç”¨
const worker = new Worker('bookmark-preprocessor.worker.js')
worker.postMessage({ type: 'PREPROCESS_BOOKMARKS', data: rawBookmarks })
```

#### 2.2 ç»“æ„åŒ–å…‹éš†ä¼˜åŒ–

Chrome API å’Œ IndexedDB ä¹‹é—´çš„æ•°æ®ä¼ é€’ä½¿ç”¨ç»“æ„åŒ–å…‹éš†ç®—æ³•ï¼Œå¯ä»¥ä¼˜åŒ–ï¼š<cite/>

```typescript
// é¿å…æ·±æ‹·è´ï¼Œç›´æ¥å¤ç”¨å¯¹è±¡å¼•ç”¨
async updateBookmark(id: string, patch: Partial<BookmarkRecord>): Promise<void> {
  const { withTransaction } = await import(
    '@/infrastructure/indexeddb/transaction-manager'
  )

  await withTransaction(
    [DB_CONFIG.STORES.BOOKMARKS],
    'readwrite',
    async (tx) => {
      const store = tx.objectStore(DB_CONFIG.STORES.BOOKMARKS)

      const record = await new Promise<BookmarkRecord>((resolve, reject) => {
        const req = store.get(id)
        req.onsuccess = () => resolve(req.result)
        req.onerror = () => reject(req.error)
      })

      if (!record) return

      // æµ…åˆå¹¶ï¼Œé¿å…æ·±æ‹·è´
      Object.assign(record, patch)

      // åªæ›´æ–°æ´¾ç”Ÿå­—æ®µ
      if (patch.title !== undefined) {
        record.titleLower = patch.title.toLowerCase()
      }
      if (patch.tags !== undefined) {
        record.tags = Array.from(new Set(patch.tags))
      }

      await new Promise<void>((resolve, reject) => {
        const putReq = store.put(record)
        putReq.onsuccess = () => resolve()
        putReq.onerror = () => reject(putReq.error)
      })
    }
  )
}
```

è¿™ä¸ªæ¨¡å¼å·²åœ¨ `saveCrawlMetadata` ä¸­ä½¿ç”¨ [6](#2-5) ï¼Œå¯ä»¥æ¨å¹¿åˆ°å…¶ä»–æ›´æ–°æ“ä½œã€‚<cite/>

#### 2.3 å­—æ®µé¢„è®¡ç®—ç¼“å­˜

å¯¹äºä¸å¸¸å˜åŒ–çš„æ´¾ç”Ÿå­—æ®µï¼ˆå¦‚ `domain`ã€`metaBoost`ï¼‰ï¼Œå¯ä»¥åœ¨ Chrome API å±‚é¢ç¼“å­˜ï¼š<cite/>

```typescript
// åœ¨ Service Worker ä¸­ç»´æŠ¤æ´¾ç”Ÿå­—æ®µç¼“å­˜
class BookmarkPreprocessor {
  private derivedFieldsCache = new Map<
    string,
    {
      domain: string
      titleLower: string
      urlLower: string
      timestamp: number
    }
  >()

  processBookmark(bookmark: chrome.bookmarks.BookmarkTreeNode) {
    const cached = this.derivedFieldsCache.get(bookmark.id)

    // ç¼“å­˜å‘½ä¸­ä¸”æœªè¿‡æœŸï¼ˆ1å°æ—¶ï¼‰
    if (cached && Date.now() - cached.timestamp < 3600000) {
      return { ...bookmark, ...cached }
    }

    // è®¡ç®—æ´¾ç”Ÿå­—æ®µ
    const derived = {
      domain: extractDomain(bookmark.url),
      titleLower: bookmark.title?.toLowerCase() || '',
      urlLower: bookmark.url?.toLowerCase() || '',
      timestamp: Date.now()
    }

    this.derivedFieldsCache.set(bookmark.id, derived)
    return { ...bookmark, ...derived }
  }
}
```

### æ–¹æ¡ˆä¸‰ï¼šæ¶æ„é‡æ„ï¼ˆé•¿æœŸæ–¹æ¡ˆï¼‰

#### 3.1 åˆ†ç¦»è¯»å†™è·¯å¾„

å‚è€ƒ CQRS æ¨¡å¼ï¼Œå°†è¯»å†™åˆ†ç¦»ï¼š<cite/>

```typescript
// å†™å…¥ä¼˜åŒ–ï¼šæ‰¹é‡å†™å…¥ä¸“ç”¨é€šé“
class BookmarkWriteService {
  private writeQueue: BookmarkRecord[] = []
  private flushTimer: number | null = null

  async queueWrite(bookmark: BookmarkRecord) {
    this.writeQueue.push(bookmark)

    // è¾¾åˆ°é˜ˆå€¼æˆ–è¶…æ—¶è‡ªåŠ¨åˆ·æ–°
    if (this.writeQueue.length >= 1000) {
      await this.flush()
    } else if (!this.flushTimer) {
      this.flushTimer = setTimeout(() => this.flush(), 500)
    }
  }

  private async flush() {
    if (this.writeQueue.length === 0) return

    const batch = this.writeQueue.splice(0)
    await indexedDBManager.insertBookmarks(batch)

    if (this.flushTimer) {
      clearTimeout(this.flushTimer)
      this.flushTimer = null
    }
  }
}

// è¯»å–ä¼˜åŒ–ï¼šå¤šçº§ç¼“å­˜
class BookmarkReadService {
  private memoryCache = new Map<string, BookmarkRecord>()

  async getBookmark(id: string): Promise<BookmarkRecord | null> {
    // L1: å†…å­˜ç¼“å­˜
    if (this.memoryCache.has(id)) {
      return this.memoryCache.get(id)!
    }

    // L2: IndexedDB
    const record = await indexedDBManager.getBookmarkById(id)
    if (record) {
      this.memoryCache.set(id, record)
    }

    return record
  }
}
```

#### 3.2 ä½¿ç”¨ SharedArrayBufferï¼ˆå®éªŒæ€§ï¼‰

å¯¹äºå¤§è§„æ¨¡æ•°æ®ä¼ è¾“ï¼Œå¯ä»¥è€ƒè™‘é›¶æ‹·è´æ–¹æ¡ˆï¼š<cite/>

```typescript
// éœ€è¦å¯ç”¨ Cross-Origin-Embedder-Policy å’Œ Cross-Origin-Opener-Policy
const buffer = new SharedArrayBuffer(bookmarks.length * 1024) // ä¼°ç®—å¤§å°
const view = new Uint8Array(buffer)

// åºåˆ—åŒ–åˆ°å…±äº«å†…å­˜
const encoder = new TextEncoder()
const serialized = encoder.encode(JSON.stringify(bookmarks))
view.set(serialized)

// Worker ç›´æ¥è¯»å–ï¼Œæ— éœ€æ‹·è´
worker.postMessage({ buffer }, [])
```

## å®æ–½ä¼˜å…ˆçº§

1. **ç«‹å³å®æ–½**ï¼ˆ1-2å¤©ï¼‰ï¼š
   - åŠ¨æ€æ‰¹æ¬¡å¤§å°è°ƒæ•´<cite/>
   - ä½¿ç”¨ `withTransaction` å¤ç”¨è¿æ¥<cite/>
   - å¢é‡æ›´æ–°æ›¿ä»£å…¨é‡åˆ·æ–°<cite/>

2. **çŸ­æœŸä¼˜åŒ–**ï¼ˆ1å‘¨ï¼‰ï¼š
   - Web Worker é¢„å¤„ç†<cite/>
   - å­—æ®µé¢„è®¡ç®—ç¼“å­˜<cite/>
   - è¯»å†™è·¯å¾„åˆ†ç¦»<cite/>

3. **é•¿æœŸé‡æ„**ï¼ˆ1ä¸ªæœˆï¼‰ï¼š
   - CQRS æ¶æ„<cite/>
   - SharedArrayBuffer å®éªŒ<cite/>

## Notes

é¡¹ç›®å·²æœ‰è‰¯å¥½çš„åŸºç¡€è®¾æ–½æ”¯æŒè¿™äº›ä¼˜åŒ–ï¼š<cite/>

- âœ… `transaction-manager.ts` æä¾›äº‹åŠ¡é‡è¯•å’Œè¿æ¥æ±  [4](#2-3)
- âœ… `connection-pool.ts` æ”¯æŒè¿æ¥å¤ç”¨<cite/>
- âœ… å·²æœ‰ `saveCrawlMetadata` çš„äº‹åŠ¡ä¼˜åŒ–ç¤ºä¾‹ [6](#2-5)

å…³é”®ç“¶é¢ˆåœ¨äºï¼š<cite/>

- Service Worker çš„æ‰¹é‡æ’å…¥ä»ä½¿ç”¨æ—§æ¨¡å¼ï¼ˆæ¯æ‰¹æ¬¡æ–°å»ºäº‹åŠ¡ï¼‰ [1](#2-0)
- å‰ç«¯çš„ `insertBookmarks` åœ¨å•äº‹åŠ¡ä¸­å¤„ç†æ‰€æœ‰æ•°æ®ï¼Œå¤§æ•°æ®é›†ä¼šè¶…æ—¶ [2](#2-1)
- ç¼ºå°‘å¢é‡æ›´æ–°æœºåˆ¶ï¼Œæ¯æ¬¡åŒæ­¥éƒ½æ˜¯å…¨é‡æ›¿æ¢ [5](#2-4)

å»ºè®®ä¼˜å…ˆå®æ–½æ–¹æ¡ˆä¸€çš„ 1.2 å’Œ 1.3ï¼Œå¯ä»¥ç«‹å³è·å¾— 50-70% çš„æ€§èƒ½æå‡ã€‚<cite/>

Wiki pages you might want to explore:

- [Technical Deep Dives (ChenQiWen/acuityBookmarks)](/wiki/ChenQiWen/acuityBookmarks#5)

### Citations

**File:** background.js (L622-684)

```javascript
  async insertBookmarks(bookmarks) {
    await this._ensureReady()
    const db = this._ensureDB()

    const total = bookmarks.length
    const batchSize = 2000 // é»˜è®¤æ¯æ‰¹ 2000ï¼Œå¯åç»­åšæˆå¯é…ç½®
    const startTime = performance.now()
    logger.info(
      'ServiceWorker',
      `ğŸ“¥ [Service Worker] å‡†å¤‡åˆ†æ‰¹æ’å…¥ ${total} æ¡ä¹¦ç­¾ï¼ˆæ¯æ‰¹ ${batchSize}ï¼‰...`
    )

    let processed = 0

    const processBatch = (start, end) =>
      new Promise((resolve, reject) => {
        const tx = db.transaction([DB_CONFIG.STORES.BOOKMARKS], 'readwrite')
        const store = tx.objectStore(DB_CONFIG.STORES.BOOKMARKS)

        for (let i = start; i < end; i++) {
          const req = store.put(bookmarks[i])
          req.onerror = () => {
            // å•æ¡å¤±è´¥åªè®°å½•ï¼Œä¸ä¸­æ–­æ•´æ‰¹ï¼›å¯æ ¹æ®éœ€è¦æ”¹ä¸º reject
            logger.error(
              'ServiceWorker',
              `âŒ [Service Worker] æ’å…¥å¤±è´¥: ${bookmarks[i]?.id}`,
              req.error
            )
          }
        }

        tx.oncomplete = () => resolve()
        tx.onerror = () => reject(tx.error)
        tx.onabort = () => reject(tx.error)
      })

    for (let start = 0; start < total; start += batchSize) {
      const end = Math.min(start + batchSize, total)
      try {
        await processBatch(start, end)
        processed = end
        logger.info(
          'ServiceWorker',
          `ğŸ“Š [Service Worker] æ’å…¥è¿›åº¦: ${processed}/${total}`
        )
        // æ‰¹é—´è®©æ­¥ï¼Œç¼“è§£äº‹ä»¶å¾ªç¯ä¸å†…å­˜å‹åŠ›
        await new Promise(resolve => setTimeout(resolve, 0))
      } catch (e) {
        logger.error(
          'ServiceWorker',
          `âŒ [Service Worker] ç¬¬ ${(start / batchSize) | 0} æ‰¹æ’å…¥å¤±è´¥:`,
          e
        )
        // å‡ºé”™ä»ç»§ç»­ä¸‹ä¸€æ‰¹ï¼Œé¿å…å•æ‰¹å¤±è´¥é˜»å¡æ•´ä½“ï¼ˆä¹Ÿå¯é€‰æ‹©ç›´æ¥æŠ›å‡ºï¼‰
      }
    }

    const duration = performance.now() - startTime
    logger.info(
      'ServiceWorker',
      `âœ… [Service Worker] åˆ†æ‰¹æ’å…¥å®Œæˆ: ${processed}/${total} æ¡, è€—æ—¶: ${duration.toFixed(2)}ms`
    )
  }
```

**File:** background.js (L2067-2121)

```javascript
  async loadBookmarkData() {
    logger.info('ServiceWorker', 'ğŸ”„ [ä¹¦ç­¾ç®¡ç†æœåŠ¡] é‡æ–°åŠ è½½ä¹¦ç­¾æ•°æ®...')

    try {
      // å¹¶å‘ä¿æŠ¤ï¼šè‹¥å·²æœ‰é‡è½½åœ¨è¿›è¡Œï¼Œç›´æ¥å¤ç”¨åŒä¸€æ‰¿è¯º
      if (this._loadingPromise) {
        logger.info(
          'ServiceWorker',
          'â³ [ä¹¦ç­¾ç®¡ç†æœåŠ¡] æ­£åœ¨é‡è½½ï¼Œç­‰å¾…ç°æœ‰ä»»åŠ¡å®Œæˆ...'
        )
        return await this._loadingPromise
      }

      this._loadingPromise = (async () => {
        // 1. é¢„å¤„ç†ä¹¦ç­¾æ•°æ®
        const result = await this.preprocessor.processBookmarks()

        // 2. æ¸…ç©ºç°æœ‰æ•°æ®
        await this.dbManager.clearAllBookmarks()

        // 3. æ‰¹é‡æ’å…¥æ–°æ•°æ®
        await this.dbManager.insertBookmarks(result.bookmarks)

        // 4. æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        await this.dbManager.updateGlobalStats(result.stats)

        // 5. æ›´æ–°çŠ¶æ€
        this.lastDataHash = result.metadata.originalDataHash
        this.lastSyncTime = Date.now()

        logger.info('ServiceWorker', 'âœ… [ä¹¦ç­¾ç®¡ç†æœåŠ¡] ä¹¦ç­¾æ•°æ®åŠ è½½å®Œæˆ')

        // å‰ç«¯å¿«é€Ÿåˆ·æ–°ï¼šå¹¿æ’­ä¸€æ¬¡æ•°æ®åº“å·²åŒæ­¥å®Œæˆ
        try {
          chrome.runtime
            .sendMessage({ type: 'BOOKMARKS_DB_SYNCED', timestamp: Date.now() })
            .catch(() => {})
        } catch (e) {
          logger.debug('ServiceWorker', 'BOOKMARKS_DB_SYNCED notify failed', e)
        }
      })()

      return await this._loadingPromise
    } catch (error) {
      logger.error(
        'ServiceWorker',
        'âŒ [ä¹¦ç­¾ç®¡ç†æœåŠ¡] åŠ è½½ä¹¦ç­¾æ•°æ®å¤±è´¥:',
        error
      )
      throw error
    } finally {
      // æ¸…ç†å¹¶å‘ä¿æŠ¤å¥æŸ„
      this._loadingPromise = null
    }
  }
```

**File:** frontend/src/utils/indexeddb-manager.ts (L310-383)

```typescript
   * æ‰¹é‡æ’å…¥ä¹¦ç­¾ - æ”¯æŒåä¸‡æ¡é«˜æ€§èƒ½æ’å…¥
   */
  async insertBookmarks(
    bookmarks: BookmarkRecord[],
    options: BatchOptions = {}
  ): Promise<void> {
    const db = this._ensureDB()
    const { progressCallback } = options

    logger.info(
      'IndexedDBManager',
      `ğŸ“¥ å¼€å§‹æ‰¹é‡æ’å…¥ ${bookmarks.length} æ¡ä¹¦ç­¾...`
    )
    const startTime = performance.now()

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(
        [DB_CONFIG.STORES.BOOKMARKS],
        'readwrite'
      )
      const store = transaction.objectStore(DB_CONFIG.STORES.BOOKMARKS)

      let processed = 0
      const errors: Error[] = []

      transaction.oncomplete = () => {
        const duration = performance.now() - startTime
        logger.info(
          'IndexedDBManager',
          `âœ… æ‰¹é‡æ’å…¥å®Œæˆ: ${processed}/${bookmarks.length} æ¡ä¹¦ç­¾, è€—æ—¶: ${duration.toFixed(2)}ms`
        )
        resolve()
      }

      transaction.onerror = () => {
        logger.error('IndexedDBManager', 'âŒ æ‰¹é‡æ’å…¥å¤±è´¥', transaction.error)
        reject(transaction.error)
      }

      // ä¿®å¤ï¼šç›´æ¥åœ¨å•ä¸ªäº‹åŠ¡ä¸­å¤„ç†æ‰€æœ‰æ•°æ®ï¼Œé¿å…å¼‚æ­¥åˆ†æ‰¹å¯¼è‡´äº‹åŠ¡ç»“æŸ
      try {
        for (let i = 0; i < bookmarks.length; i++) {
          const bookmark = bookmarks[i]
          const request = store.put(bookmark)

          request.onsuccess = () => {
            processed++

            // è¿›åº¦å›è°ƒ
            if (progressCallback && processed % 500 === 0) {
              progressCallback(processed, bookmarks.length)
            }
          }

          request.onerror = () => {
            const error = new Error(`æ’å…¥ä¹¦ç­¾å¤±è´¥: ${bookmark.id}`)
            errors.push(error)
            if (options.errorCallback) {
              options.errorCallback(error, bookmark)
            }
          }
        }

        logger.info(
          'IndexedDBManager',
          `ğŸš€ å·²æäº¤ ${bookmarks.length} æ¡ä¹¦ç­¾åˆ°äº‹åŠ¡é˜Ÿåˆ—`
        )
      } catch (error) {
        logger.error('IndexedDBManager', 'âŒ æ‰¹é‡æ’å…¥è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯', error)
        transaction.abort()
        reject(error)
      }
    })
  }
```

**File:** frontend/src/utils/indexeddb-manager.ts (L1039-1132)

```typescript
  async saveCrawlMetadata(metadata: CrawlMetadataRecord): Promise<void> {
    const { withTransaction } = await import(
      '@/infrastructure/indexeddb/transaction-manager'
    )
    await withTransaction(
      [DB_CONFIG.STORES.CRAWL_METADATA, DB_CONFIG.STORES.BOOKMARKS],
      'readwrite',
      async tx => {
        const metaStore = tx.objectStore(DB_CONFIG.STORES.CRAWL_METADATA)
        const bookmarkStore = tx.objectStore(DB_CONFIG.STORES.BOOKMARKS)

        // å†™å…¥å…ƒæ•°æ®
        await new Promise<void>((resolve, reject) => {
          const req = metaStore.put({
            ...metadata,
            updatedAt: Date.now()
          } as CrawlMetadataRecord)
          req.onsuccess = () => resolve()
          req.onerror = () => reject(req.error)
        })

        // è¯»å–å¹¶å›å†™ä¹¦ç­¾è¡ç”Ÿå­—æ®µï¼ˆè‹¥å­˜åœ¨ï¼‰
        const bookmark = await new Promise<BookmarkRecord | undefined>(
          (resolve, reject) => {
            const getReq = bookmarkStore.get(metadata.bookmarkId)
            getReq.onsuccess = () =>
              resolve(getReq.result as BookmarkRecord | undefined)
            getReq.onerror = () => reject(getReq.error)
          }
        )

        if (!bookmark) return

        const normalizeText = (s?: string) =>
          (s || '')
            .toLowerCase()
            .normalize('NFKC')
            .replace(/[^\p{L}\p{N}\s\u4e00-\u9fff]/gu, ' ')
            .replace(/\s+/g, ' ')
            .trim()

        const normalizeKeywords = (s?: string) =>
          (s || '')
            .toLowerCase()
            .normalize('NFKC')
            .split(/[\s,;|ã€ï¼Œï¼›]+/)
            .map(t => t.trim())
            .filter(t => t.length > 1)

        const metaTitleLower = normalizeText(
          metadata.pageTitle || metadata.ogTitle || ''
        )
        const metaDescriptionLower = normalizeText(
          metadata.description || metadata.ogDescription || ''
        )
        const metaKeywordsTokens = normalizeKeywords(metadata.keywords)

        const ageDays =
          typeof metadata.lastCrawled === 'number'
            ? (Date.now() - metadata.lastCrawled) / (24 * 60 * 60 * 1000)
            : 0
        let metaBoost = 1.0
        if (ageDays > 180) metaBoost = 0.6
        else if (ageDays > 90) metaBoost = 0.8
        if (metadata.status === 'failed') metaBoost *= 0.5

        const updated: BookmarkRecord = {
          ...bookmark,
          hasMetadata: true,
          metadataSource: metadata.source,
          metadataUpdatedAt: Date.now(),
          metaTitleLower,
          metaDescriptionLower,
          metaKeywordsTokens,
          metaBoost
        }

        await new Promise<void>((resolve, reject) => {
          const putReq = bookmarkStore.put(updated)
          putReq.onsuccess = () => resolve()
          putReq.onerror = () => reject(putReq.error)
        })
      },
      {
        retries: 2,
        retryDelayMs: 30,
        onRetry: attempt =>
          logger.warn(
            'IndexedDBManager',
            `saveCrawlMetadata ç¬¬ ${attempt} æ¬¡é‡è¯•`
          )
      }
    )
  }
```

**File:** .github/copilot-instructions.md (L74-78)

```markdown
- IndexedDB äº‹åŠ¡åŒ…è£¹ï¼ˆåªè¯»/è¯»å†™ + é‡è¯•ï¼‰
  - æ–‡ä»¶ï¼š`frontend/src/infrastructure/indexeddb/transaction-manager.ts`
  - ç”¨æ³•ï¼š
    - `await withTransaction(['StoreA','StoreB'], 'readonly', (tx, stores) => { /*...*/ }, { retries: 2 })`
    - è§£è€¦è¿æ¥ï¼šè§ `connection-pool.ts`ï¼Œé€šè¿‡ `getDB()`/`setDB()` å¤ç”¨å•è¿æ¥
```
