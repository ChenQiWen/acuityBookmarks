# Store 架构分析与优化方案

## 📊 当前 Store 结构分析

### 现有 Store 文件

1. **`ui-store.ts`** (305行) - UI状态管理
2. **`management-store.ts`** (1597行) - 管理页面状态
3. **`bookmarkStore.ts`** (308行) - 书签数据管理
4. **`popup-store-indexeddb.ts`** (497行) - 弹窗状态管理

### 🔍 主要问题识别

#### 1. **职责混乱与重复**

- **management-store.ts** 过于庞大（1597行），承担了过多职责：
  - 书签树管理
  - 清理计划执行
  - 搜索与健康扫描
  - 数据同步
  - 错误处理
  - UI状态管理

- **bookmarkStore.ts** 与 **management-store.ts** 存在功能重叠：
  - 都管理书签树结构
  - 都有数据加载和更新逻辑
  - 都有错误处理机制

#### 2. **错误处理不统一**

- **多种错误处理模式并存**：

  ```typescript
  // 模式1: 简单try-catch + logger
  try {
    // 操作
  } catch (error) {
    logger.error('Store', '操作失败:', error)
  }

  // 模式2: 设置lastError状态
  try {
    // 操作
  } catch (error) {
    lastError.value = `操作失败: ${error.message}`
  }

  // 模式3: 直接抛出错误
  if (!result.ok) {
    throw new Error(result.error)
  }
  ```

- **缺乏统一的错误分类和处理策略**
- **用户友好的错误消息缺失**
- **错误恢复机制不完善**

#### 3. **状态管理复杂**

- **状态分散**：相关状态分散在多个Store中
- **状态同步问题**：多个Store管理相似数据，容易出现不一致
- **状态更新复杂**：缺乏统一的状态更新模式

#### 4. **业务逻辑与UI逻辑混合**

- Store中包含了大量业务逻辑，应该放在Application层
- UI状态与业务状态混合，难以测试和维护

## 🎯 优化目标

### 1. **精简Store职责**

- **UI Store**: 仅管理UI状态（展开/收起、加载状态等）
- **Data Store**: 仅管理数据状态（书签树、搜索结果等）
- **移除业务逻辑**: 将业务逻辑迁移到Application层

### 2. **统一错误处理**

- **统一错误类型**: 使用`Result<T, E>`模式
- **统一错误处理**: 集中错误处理逻辑
- **用户友好消息**: 提供清晰的错误提示
- **错误恢复**: 实现自动重试和降级策略

### 3. **简化状态管理**

- **单一数据源**: 避免数据重复
- **清晰的状态边界**: 明确各Store的职责范围
- **统一的状态更新**: 使用一致的状态更新模式

## 🏗️ 重构方案

### 阶段1: 错误处理统一化

1. **创建统一错误处理服务**
2. **实现Result模式**
3. **统一错误分类和消息**

### 阶段2: Store职责分离

1. **精简UI Store**: 仅保留UI相关状态
2. **重构Data Store**: 专注于数据管理
3. **移除业务逻辑**: 迁移到Application层

### 阶段3: 状态管理优化

1. **统一状态更新模式**
2. **实现状态同步机制**
3. **优化性能**

## 📋 具体实施计划

### 1. 错误处理统一化

- [ ] 创建`StoreErrorHandler`服务
- [ ] 实现统一的错误处理中间件
- [ ] 更新所有Store使用新的错误处理模式
- [ ] 添加用户友好的错误消息

### 2. Store精简

- [ ] 分析并分离UI状态和业务状态
- [ ] 将业务逻辑迁移到Application层
- [ ] 简化Store接口
- [ ] 优化状态更新逻辑

### 3. 状态管理优化

- [ ] 实现统一的状态更新模式
- [ ] 添加状态同步机制
- [ ] 优化性能
- [ ] 添加状态持久化

## 🎯 预期收益

### 1. **可维护性提升**

- 清晰的职责分离
- 统一的错误处理
- 简化的状态管理

### 2. **可测试性提升**

- 业务逻辑与UI逻辑分离
- 统一的错误处理模式
- 简化的状态结构

### 3. **用户体验提升**

- 统一的错误提示
- 更好的错误恢复
- 更稳定的状态管理

### 4. **开发效率提升**

- 清晰的代码结构
- 统一的开发模式
- 更好的代码复用
